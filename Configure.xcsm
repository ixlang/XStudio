class Configure : IConfigure
{
    public String name;
    public JsonObject root;
    bool bModified = false;

    Map<String, String> filemd5s = new Map<String, String>();

    // Map<String, String> newfilemd5s = new Map<String, String>();

    public Configure()
    {
    }

    public String getCachedMd5(String path)
    {
        String md5 = nilptr;
        try {
            md5 = filemd5s.get(path);
        } catch(Exception e) {

        }

        if (md5 == nilptr) {
            md5 = "";
        }
        return md5;
    }

    public bool isModified(String srcpath)
    {
        String md5 = getFileMd5(srcpath);
        String cached = getCachedMd5(srcpath);
        if (md5.equals(cached) == false) {
            //newfilemd5s.put(srcpath, md5);
            filemd5s.put(srcpath, md5);
            return true;
        }
        return false;
    }

    public void resetCache()
    {
        filemd5s.clear();
    }

    /*void updateMd5s(){
    	Map.Iterator<String, String> iter = newfilemd5s.iterator();
        while (iter.hasNext()){
    		filemd5s.put(iter.getKey(), iter.getValue());
            iter.next();
        }
    }*/

    public static String getFileMd5(String file)
    {

        String md5 = "unknow";

        FileInputStream fis =  nilptr;
        long hm = 0;
        try {
            fis = new FileInputStream(file);

            hm = Crypto.Md5Init();
            if (hm != 0) {
                byte[] data = new byte[4096];

                long readed = 0;
                while ((readed = fis.read(data, 0, 4096)) > 0) {
                    Crypto.Md5Update(hm, data, 0, readed);
                }
                Crypto.MD5Final(hm);
                byte [] mv = Crypto.MD5Get(hm);

                md5 = "";
                for (int i =0; i < mv.length; i++) {
                    md5 = md5 + String.format("%02X",mv[i]);
                }
            }
        } catch(Exception e) {

        } finally{
            if (fis != nilptr)
            {
                fis.close();
            }
            if (hm != 0)
            {
                Crypto.MD5Close(hm);
            }
        }

        if (md5 == nilptr || md5.length() == 0) {
            md5 = "unknow";
        }

        return md5;
    }

    public Configure(String _name, JsonObject _root)
    {
        name = _name;
        root = _root;
    }

    public bool setOption(String key, String text)override
    {
        bModified = true;
        if (key.indexOf('.') == -1){
            root.remove(key);
            root.put(key, text);
            return true;
        }else{
            String [] sec = key.split('.');
            JsonObject parent = root;
            try{
                for (int i = 0; i < sec.length && parent != nilptr; i++ ){
                    String _key = sec[i].trim(true);
                    
                    if (i + 1 == sec.length){
                        while (parent.has(_key)){
                            parent.remove(_key);
                        }
                        parent.put(_key, text);
                        return true;
                    }else{
                        parent = (JsonObject)parent.get(_key);
                        if (parent == nilptr){
                            JsonObject _newnode = new JsonObject();
                            parent.put(_key, _newnode);
                            parent = _newnode;
                        }
                    }
                }
            }catch(Exception e){
                
            }
        }
        return false;
    }

    public void save()override
    {
        bModified = false;
    }

    public bool isModified()override
    {
        return bModified;
    }

    public Configure clone(String newName)
    {
        String txt = root.toString(false);
        JsonObject newobj = new JsonObject(txt);
        newobj.remove("name");
        newobj.put("name", newName);
        return new Configure(newName, newobj);
    }
    //----------------------------------------
    public void setLibs(String text)override
    {
        String [] paths = text.split(';');
        JsonArray libpath = new JsonArray();
        for (int i = 0; i < paths.length; i++) {
            if (paths[i].length() > 0) {
                libpath.put(paths[i]);
            }
        }
        root.remove("libs");
        root.put("libs", libpath);
        bModified = true;
    }

    public void setLinks(String text)override
    {
        String [] paths = text.split(';');
        JsonArray libpath = new JsonArray();
        for (int i = 0; i < paths.length; i++) {
            if (paths[i].length() > 0) {
                libpath.put(paths[i]);
            }
        }
        root.remove("links");
        root.put("links", libpath);
        bModified = true;
    }

    public String getLibs()override
    {
        JsonArray libpath = (JsonArray)root.get("libs");
        if (libpath == nilptr) {
            return "";
        }

        String out = "";
        for (int i = 0; i < libpath.length(); i++) {
            String path = libpath.getString(i);
            if (path != nilptr && path.length() > 0) {
                if (out.length() > 0) {
                    out = out + ";";
                }
                out = out + path;
            }
        }

        return out;
    }

    public String getLinks()override
    {
        JsonArray libpath = (JsonArray)root.get("links");
        if (libpath == nilptr) {
            return "";
        }

        String out = "";
        for (int i = 0; i < libpath.length(); i++) {
            String path = libpath.getString(i);
            if (path != nilptr && path.length() > 0) {
                if (out.length() > 0) {
                    out = out + ";";
                }
                out = out + path;
            }
        }

        return out;
    }

    //--------------------------------------------------------------------
    public void setLibsPath(String text)override
    {
        String [] paths = text.split(';');
        JsonArray libpath = new JsonArray();

        for (int i = 0; i < paths.length; i++) {
            if (paths[i].length() > 0) {
                libpath.put(paths[i]);
            }
        }

        JsonObject pathObj = (JsonObject)root.get("path");
        if (pathObj == nilptr) {
            pathObj = new JsonObject();
            root.put("path", pathObj);
        }
        pathObj.remove("libpath");
        pathObj.put("libpath", libpath);
        bModified = true;
    }

    public bool addLib(String lib, String xpname, String xpver)override
    {
        bool isHas = false;

        JsonArray libs = (JsonArray)root.get("libs");

        if (libs == nilptr) {
            libs = new JsonArray();
            root.put("libs", libs);
        } else {
            for (int i = 0; i < libs.length(); i++) {
                String path = libs.getString(i);
                if (path != nilptr && path.length() > 0) {
                    if (path.equals(lib)) {
                        isHas = true;
                        break;
                    } else {
                        String filename = path.findFilename();
                        int pos = filename.lastIndexOf('_');
                        if (pos != -1) {
                            String pname = filename.substring(0, pos);
                            if (pname.equals(xpname)) {
                                libs.remove(i);
                            }
                        }
                    }
                }
            }
        }

        if (isHas == false) {
            libs.put(lib);
            bModified = true;
            return true;
        }
        return false;
    }

    public bool addLink(String lib, String xpname, String xpver)override
    {
        bool isHas = false;

        JsonArray libs = (JsonArray)root.get("links");

        if (libs == nilptr) {
            libs = new JsonArray();
            root.put("links", libs);
        } else {
            for (int i = 0; i < libs.length(); i++) {
                String path = libs.getString(i);
                if (path != nilptr && path.length() > 0) {
                    if (path.equals(lib)) {
                        isHas = true;
                        break;
                    } else {
                        String filename = path.findFilename();
                        int pos = filename.lastIndexOf('_');
                        if (pos != -1) {
                            String pname = filename.substring(0, pos);
                            if (pname.equals(xpname)) {
                                libs.remove(i);
                            }
                        }
                    }
                }
            }
        }

        if (isHas == false) {
            libs.put(lib);
            bModified = true;
            return true;
        }
        return false;
    }

    public bool addPathToLibpath(String path)override
    {
        JsonObject pathObj = (JsonObject)root.get("path");

        if (pathObj == nilptr) {
            pathObj = new JsonObject();
            pathObj.put("path", path);
        }

        JsonArray libpath = (JsonArray)pathObj.get("libpath");
        if (libpath == nilptr) {
            libpath = new JsonArray();
            pathObj.put("libpath", libpath);
        }

        bool isHas = false;
        for (int i = 0; i < libpath.length(); i++) {
            if (libpath.getString(i).equals(path)) {
                isHas = true;
                break;
            }
        }
        if (isHas == false) {
            libpath.put(path);
            bModified = true;
            return true;
        }
        return false;
    }
    
    public bool removeDepend(String xpname)override{
    	JsonArray depends = (JsonArray)root.get("depends");
        if (depends == nilptr){
    		depends = new JsonArray();
            root.put("depends", depends);
            return false;
        }

        for (int i = 0; i < depends.length(); i++){
    		JsonObject depend = (JsonObject)depends.get(i);
            if (depend != nilptr){
    			String pname = depend.getString("name");
                if (pname != nilptr && pname.equals(xpname)){
    				depends.remove(i);
                    return true;
                }
            }
        }
        return false;
    }


    public String getDependsString()override{
        String strOut = "";
        
        JsonArray depends = (JsonArray)root.get("depends");
        if (depends == nilptr){
    		depends = new JsonArray();
            root.put("depends", depends);
            return strOut;
        }
        
        for (int i = 0; i < depends.length(); i++){
    		JsonObject depend = (JsonObject)depends.get(i);
            if (depend != nilptr){
    			String pname = depend.getString("name");
                String pversion = depend.getString("version");
                if (strOut.length() != 0){
                    strOut = strOut + ";";
                }
                
                strOut = strOut + pname;
                if (pversion != nilptr){
                    strOut = strOut + "-Ver:" + pversion;
                }
            }
        }
        return strOut;
    }
    
    public void setDependsString(String value)override{
        String [] pkgs = value.split(';');
        JsonArray depends = new JsonArray();
        
        for (int i = 0; i < pkgs.length; i++){
            int pos = pkgs[i].lastIndexOf("-Ver:");
            JsonObject depend = new JsonObject();
            if (pos != -1){
                String _name = pkgs[i].substring(0, pos);
                String _version = pkgs[i].substring(pos + 5, pkgs[i].length());
                
                depend.put("name",_name);
                depend.put("version",_version);
            }else{
                depend.put("name",pkgs[i]);
            }
            depends.put(depend);
        }
        
        root.remove("depends");
        root.put("depends", depends);
    }
    
    public bool addDepends(String xpname, String version)override{
        JsonArray depends = (JsonArray)root.get("depends");
        if (depends == nilptr){
    		depends = new JsonArray();
            root.put("depends", depends);
        }

        JsonObject depend = new JsonObject();
        depend.put("name", xpname);
        depend.put("version", version);
    	depends.put(depend);
        return true;
    }
    
    public int getArchId()override
    {
        String [] archs = {"", "-arch:x86", "-arch:x86_64", "-arch:arm", "-arch:arm64", "-arch:mips"};
        String arch = getOption("wtype");

        int archid = _system_.getArchId();

        if (arch.length() > 0) {
            for (int i = 0; i < archs.length; i++) {
                if (archs[i].equals(arch)) {
                    archid = i;
                    break;
                }
            }
        }
        return archid;
    }

    public String getLibsPath()override
    {

        JsonObject pathObj = (JsonObject)root.get("path");
        if (pathObj == nilptr) {
            return "";
        }

        JsonArray libpath = (JsonArray)pathObj.get("libpath");
        if (libpath == nilptr) {
            return "";
        }

        String out = "";
        for (int i = 0; i < libpath.length(); i++) {
            String path = libpath.getString(i);
            if (path != nilptr && path.length() > 0) {
                if (out.length() > 0) {
                    out = out + ";";
                }
                out = out + path;
            }
        }

        return out;
    }

    public String getIncsPath()override
    {
        JsonObject pathObj = (JsonObject)root.get("path");
        if (pathObj == nilptr) {
            return "";
        }

        JsonArray libpath = (JsonArray)pathObj.get("incpath");
        if (libpath == nilptr) {
            return "";
        }

        String out = "";
        for (int i = 0; i < libpath.length(); i++) {
            String path = libpath.getString(i);
            if (path != nilptr && path.length() > 0) {
                if (out.length() > 0) {
                    out = out + ";";
                }
                out = out + path;
            }
        }

        return out;
    }

    
    
    public void setIncsPath(String text)override
    {
        String [] paths = text.split(';');
        JsonArray incpath = new JsonArray();
        for (int i = 0; i < paths.length; i++) {
            if (paths[i].length() > 0) {
                incpath.put(paths[i]);
            }
        }

        JsonObject pathObj = (JsonObject)root.get("path");
        if (pathObj == nilptr) {
            pathObj = new JsonObject();
            root.put("path", pathObj);
        }
        pathObj.remove("incpath");
        pathObj.put("incpath", incpath);
        bModified = true;
    }

    public String getOption(String key)override
    {
        String value = nilptr;
        
        if (key.indexOf('.') == -1){
            value = root.getString(key);
        }else{
            String [] sec = key.split('.');
            JsonObject parent = root;
            try{
                for (int i = 0; i < sec.length && parent != nilptr; i++ ){
                    if (i + 1 == sec.length){
                        value = parent.getString(sec[i]);
                    }else{
                        parent = (JsonObject)parent.get(sec[i]);
                    }
                }
            }catch(Exception e){
                
            }
        }
        
        if (value == nilptr) {
            return "";
        }
        
        return value;
    }

    public String getName()override
    {
        return name;
    }

    public bool createConfigure(String projName,JsonObject project, String configName)
    {
        root = new JsonObject();

        name = configName;
        JsonObject paths = new JsonObject();
        paths.put("incpath", new JsonArray());
        paths.put("libpath", new JsonArray());
        root.put("paths", paths);

        //root.put("source", new JsonArray());

        root.put("libs", new JsonArray());
        root.put("links", new JsonArray());
        root.put("options", "");
        root.put("command", "-ce");
        root.put("outpath", "$(ProjectDir)/$(Arch)/$(Configure)");
        root.put("outname", "$(ProjectName)$(Ext)");

        project.put(name, root);

        return true;
    }


    public void dodeploy(Project project){
        String out_path = getOption("outpath");
        out_path = String.formatPath(XlangProjectProp.map_variable(project, this, out_path), false);
        deploy(project, out_path);
    }
    
    public void dodeployto(Project project, String path){
        if (path != nilptr && path.length() > 0) {
            deploy(project, path);
        }
    }
    
    public bool deploy(Project project, String deploy_path){
    
        String _deploy_arch = getDeployArch();
        if (_deploy_arch == nilptr){
            XWndOutput.Output("无效的处理器架构.", 0);
            return false;
        }
        
        String _deploy_ostype = getDeployPlatform();
        if (_deploy_ostype == nilptr){
            XWndOutput.Output("无效的操作系统平台.", 0);
            return false;
        }
        
    	PackageManager pm = new PackageManager();
        if (false == pm.load()){
            XWndOutput.Output("无法载入包管理.", 0);
            return false;
        }
        
    	JsonArray depends = (JsonArray)root.get("depends");

        if (depends == nilptr){
    		depends = new JsonArray();
            root.put("depends", depends);
            return false;
        }

        if (deploy_path == nilptr || deploy_path.length() == 0){
    		XWndOutput.Output("部署路径错误,请先设置部署路径.", 0);
            return false;
        }
        
    	/*deploy_path = String.formatPath(XlangProjectProp.map_variable(project, this , deploy_path), false);
        if (deploy_path == nilptr || deploy_path.length() == 0){
    		XWndOutput.Output("部署路径错误,请先设置部署路径.");
            return false;
        }*/
        
        for (int i = 0; i < depends.length(); i++){
    		JsonObject depend = (JsonObject)depends.get(i);
            if (depend != nilptr){
    			String pname = depend.getString("name");
                String pversion = depend.getString("version");

                PackageManager.PackageInfo pi = pm.findPackage(pname, pversion);

                if (pi != nilptr){
    				if (false == deployPackage(deploy_path, project, pi, _deploy_arch, _deploy_ostype)){
    					XWndOutput.Output("部署包失败:" + pname + " ver:" + pversion + "\n", 0);
                    }
                }else{
                    pi = pm.findPackage(pname, nilptr);
                    
                    if (pi == nilptr){
                        XWndOutput.Output("找不到依赖包:" + pname + " ver:" + pversion + "\n", 0);
                    }else{
                        XWndOutput.Output("找不到依赖包:" + pname + " 版本:<" + pversion + "> ,但找到" + pname + " 版本:<" + pi.version + ">...\n如考虑使用不同版本,请打开[项目]->[属性] 修改 [项目设置]=>[依赖包] 项中的版本.\n", 0);
                    }
	
                }
            }
        }

        return true;
    }

    public String getDeployArch() {
        String [] archs = {"unknow", "x86", "x64", "arm", "arm64", "mips"};

        String arch = getOption("wtype");
        if (arch.equals("")) {
            return "" + _system_.getArchId();
        } else {
            if (arch.equals("-arch:x86")) {
                return "1";
            } else if (arch.equals("-arch:x86_64")) {
                return "2";
            } else if (arch.equals("-arch:arm")) {
                return "3";
            } else if (arch.equals("-arch:arm64")) {
                return "4";
            } else if (arch.equals("-arch:mips")) {
                return "5";
            } else if (arch.equals("-arch:mips64")) {
                return "6";
            } else {
                if (arch.length() > 6) {
                    return arch.substring(6,arch.length());
                }
                return arch;
            }
        }
        return nilptr;
    }
    
    public String getDeployPlatform(){
        String arch = getOption("ostype");
        if (arch.equals("")) {
            return "" + _system_.getPlatformId();
        }else{
            if (arch.length() > 8){
                arch = arch.substring(8, arch.length());
                
                if (arch.equals("windows")){
                    return "0";
                }else
                if (arch.equals("linux")){
                    return "1";
                }else
                if (arch.equals("darwin")){
                    return "2";
                }
                return arch;
            }
        }
        return nilptr;
    }
    
    public bool deployPackage(String deploy_path, Project project,PackageManager.PackageInfo pi, String arch, String ostype){
    	bool rt = false;
        
        String match = String.formatPath("" + arch + "/" + ostype, false);

    	try{
    		FileInputStream fis = new FileInputStream(pi.filepath);
    		ZipArchive zs = new ZipArchive();

            if (zs.open(fis)){
    			int c = zs.getEntriesCount();

    			for (int i = 0; i < c; i ++){
    				ZipEntry entry = zs.getEntry(i);
    				String name =  String.formatPath(entry.getName(), false);
    				if (name.startWith(match)){
    					ZipFile zf = entry.getFile();
                        
    					if (zf != nilptr && zf.open()){
    						String newpath = String.formatPath(deploy_path.appendPath(name.substring(3, name.length())), false);
    						XWndOutput.Output(newpath + "...\n", 0);
    						XlangProjectProp.mkdirs(newpath.findVolumePath());

    						FileOutputStream fos;
    						try{
    							fos = new FileOutputStream(newpath);
                                
    							int rd = 0;
    							byte [] data = new byte[1024];
                                
    							while ((rd = zf.read(data, 0, 1024)) > 0){
    								fos.write(data, 0, rd);
    							}
                                
    							rt = true;
    						}catch(Exception e){

    						}finally{
    							if (fos != nilptr){
    								fos.close();
    							}
    						}
                            
    						zf.close();
    					}
    				}
                }
    			zs.close();
            }

            fis.close();
        }catch(Exception e){

        }
        return rt;
    }

    public bool importPkg(Project project, PackageManager.PackageInfo pi, ZipArchive zs, String lixname, String xpname, String version)
    {
        resetCache();
        
        IXIntelliSense __IntelliSense = project.getIntelliSense();
        if (addPathToLibpath("libs")) {
            if (__IntelliSense != nilptr) {
                __IntelliSense.appendLibpath("libs");
            }
        }

        String ext = lixname.findExtension();
        
        if (ext == nilptr){ 
            return false;        
        }
        
        if (ext.equals(".lix")){
            if (addLib(lixname, xpname, version)) {
                    __IntelliSense.appendLib(lixname);
                
            } 
        }else{
            if (addLink(lixname, xpname, version)) {
                    __IntelliSense.appendLink(lixname);
                
            } 
        }
        

        addDepends(xpname, version);
        /*if (addLink(lixname, xpname, version)){
        	if (project.intelliSense != nilptr){
        		project.intelliSense.appendLink(lixname);
            }
        }*/

        bool rt = false;

        XWndOutput.Output("为 " + this.name + " 配置引用...\n", 0);

        int c = zs.getEntriesCount();

        String out_path = getOption("outpath");
        out_path = String.formatPath(XlangProjectProp.map_variable(project, this, out_path), false);

        String match = String.formatPath("" + getArchId() + "/" + _system_.getPlatformId(), false);

        XWndOutput.Output("为 " + this.name + " 部署运行时文件...\n", 0);

        for (int i = 0; i < c; i ++) {
            ZipEntry entry = zs.getEntry(i);
            String name =  String.formatPath(entry.getName(), false);
            if (name.startWith(match)) {
                ZipFile zf = entry.getFile();
                if (zf != nilptr && zf.open()) {

                    String newpath = String.formatPath(out_path.appendPath(name.substring(3, name.length())), false);
                    XWndOutput.Output(newpath + "...", 0);
                    XlangProjectProp.mkdirs(newpath.findVolumePath());

                    FileOutputStream fos ;
                    try {
                        fos = new FileOutputStream(newpath);
                        int rd = 0;
                        byte [] data = new byte[1024];
                        while ((rd = zf.read(data, 0, 1024)) > 0) {
                            fos.write(data, 0, rd);
                        }
                        XWndOutput.Output("成功.\n", 0);
                        rt = true;
                    } catch(Exception e) {

                    } finally{
                        if (fos != nilptr)
                        {
                            fos.close();
                        }
                    }
                    zf.close();
                }
            }
        }
        XWndOutput.Output("\n", 0);
        return rt;
    }
};