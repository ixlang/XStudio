
class XlangProjectProp : ProjectPropInterface {

    static const String _compile_path = ("bin/xlang.exe");
    static const String _compile_path_linux = ("bin/xlang");

    static const String warning = "警告:";
    static const String error = "错误:";
    static const String tips = "提示:";

    int XDEBUG_SERIAL = 0;

    Process process ;
    Object process_lock = new Object();
    XDebugPipe _debug_pipe;
    
    public static class CompileInfo : ICompileInfo {
        String file;
        int line;
        int row;
        int type;
        String tip;
        
        public CompileInfo(String f, int l,int r, String i) {
            file = f;
            line = l;
            row = r;
            tip = i;
        }

        public CompileInfo(@NotNilptr String text, int t, String _tips) {
            int pos = text.lastIndexOf("(");
            int rpos = text.lastIndexOf(")");
            if (pos != -1 && rpos != -1) {

                file = text.substring(0, pos);
                String linerow = text.substring(pos + 1, rpos);

                String []lr = linerow.split(',');
                if (lr.length == 2) {

                    int m = lr[0].indexOf(':');

                    if (m != -1) {
                        line = lr[0].substring(m + 1, lr[0].length()).parseInt();
                    }

                    m = lr[1].indexOf(':');

                    if (m != -1) {
                        row = lr[1].substring(m + 1, lr[1].length()).parseInt();
                    }
                }

                if (_tips != nilptr) {
                    byte [] tipdata = _tips.getBytes();
                    try {
                        tip = new String(tipdata, "CP936");
                    } catch(Exception e) {
                        tip = new String(tipdata);
                    }
                }
                type = t;
            } else {
                type = -1;
            }
        }
        
        int getType()override {
            return type;
        }
        String getFile()override {
            return file;
        }
        int getLine()override {
            return line;
        }
        int getRow()override {
            return row;
        }
        @NotNilptr String getTips() {
            __nilptr_safe(tip);
            if (tip == nilptr){
                return "";
            }
            return tip;
        }
    };

     
    public String readFileContent(@NotNilptr String file){
        FileInputStream fis = nilptr;
        try{
            fis = new FileInputStream(file);
        }catch(Exception e){
            _system_.consoleWrite("canot read file " + file);
        }
        
        if (fis != nilptr){
            byte []data = fis.read();
            return new String(data);
        }
        
        return nilptr;
    }
    
    public String [] generatorCompArgs(Project object, Configure configure, String sourfile){
        return nilptr;
    }
    public void onProjectSettingChange(@NotNilptr Project object)override{
        if (object.getIntelliSense() == nilptr){
            object.reinitIntelliSense();
        }
    }
    public void mergeProp(@NotNilptr JsonObject marjon, @NotNilptr JsonObject extroot){
		
		String name = extroot.getName();
		if (marjon.has(name)){
			JsonObject marjonParent = (JsonObject)marjon.get(name);
            JsonObject child = (JsonObject)extroot.child();
            
            if (marjonParent != nilptr){
                if (extroot.has("type")){
                    String type = extroot.getString("type");
                    if (type != nilptr && type.equals("stringlist")){
                        JsonArray list = (JsonArray)marjonParent.get("list");
                        JsonArray extlist = (JsonArray)extroot.get("list");
                        if (list != nilptr && extlist != nilptr){
                            for (int i = 0, c = extlist.length(); i < c; i ++){
                                list.put(extlist.getString(i));
                            }
                        }
                    }
                }else{
                    while (child != nilptr){
                        mergeProp(marjonParent, child);
                        child = (JsonObject)child.next();
                    }
                }
            }
		}else{
			marjon.put(name, (JsonObject)extroot.child());
        }
    }
    
    public bool loadExtision(@NotNilptr JsonObject marjon, @NotNilptr String language){
		String file = _system_.getAppDirectory();
		file = file.appendPath("config").appendPath(language + ".ext");
		String content = readFileContent(file);
        if (content != nilptr){
			JsonObject _extroot = new JsonObject(content);
            
            JsonObject child = (JsonObject)_extroot.child();
            while (child != nilptr){
				mergeProp(marjon, child);
                child = (JsonObject)child.next();
            }
            
			return true;
		}
        return false;
    }
    
    String getFileExtensionFilter(){
        return "X 模块源文件(*.x *.xcs *.xcsm);;Qt UI文件(*.ui);;";
    }
    
    public JsonObject getProperitiesConfigure(){
        JsonObject _root = nilptr;
        String file = _system_.getAppDirectory();
        file = file.appendPath("config").appendPath("xlang" + ".prop");
        String content = readFileContent(file);
        if (content != nilptr){
            _root = new JsonObject(content);
            loadExtision((JsonObject)_root, "xlang");
        }
        return _root;
    }

    public static String getCompilerPath() {
        String comppath = _system_.getAppDirectory();
        if (_system_.getPlatformId() == 0) {
            comppath = comppath.appendPath(_compile_path);
        } else {
            comppath = comppath.appendPath(_compile_path_linux);
        }
        return String.formatPath(comppath,false);
    }

    public bool setValue(@NotNilptr Project object,@NotNilptr  Configure configure, @NotNilptr  String key,@NotNilptr String value)override {
        if (key.equals("projname")) {
            return true;
        }
        if (key.equals("icofile")) {
            object.setOption(key, value);
            return true;
        }
        if (key.equals("versioninc")) {
            if (value.equals("启用")) {
                object.setOption("versioninc", "1");
            } else {
                object.setOption("versioninc", "0");
            }
            return true;
        }
        if (key.equals("uaclevel")) {
            configure.setOption(key, value);
            return true;
        }
        if (key.equals("projtype")) {
            if (value.equals("xlang 可执行文件(-c)")) {
                configure.setOption("command", "-c");
                return true;
            }
            if (value.equals("可执行文件(-ce)")) {
                configure.setOption("command", "-ce");
                return true;
            }
            if (value.equals("xlang 静态链接库(-lix -c)")) {
                configure.setOption("command", "-lix -c");
                return true;
            }
            if (value.equals("xlang 共享库(-slx -c)")) {
                configure.setOption("command", "-slx -c");
                return true;
            }
            if (value.equals("xlang 链接库(-xl -c)")) {
                configure.setOption("command", "-xl -c");
                return true;
            }
            return false;
        }
        if (key.equals("wtype")) {
            if (value.equals("缺省")) {
                configure.setOption("wtype", "");
            } else {
                configure.setOption("wtype", value);
            }
            return true;
        }
        if (key.equals("ostype")) {
            if (value.equals("缺省")) {
                configure.setOption("ostype", "");
            } else {
                configure.setOption("ostype", value);
            }
            return true;
        }
        if (key.equals("sstype")) {
            if (value.equals("缺省")) {
                configure.setOption("sstype", "");
            } else {
                configure.setOption("sstype", value);
            }
            return true;
        }
        /*if (key.equals("deploypath")){
        	if (value.indexOf("$(Deploy)") != -1){
        		return false;
            }
            configure.setOption("deploypath", value);
            return true;
        }*/
        if (key.equals("projout")) {
            if (value.indexOf("$(Output)") != -1) {
                return false;
            }
            configure.setOption("outpath", value);
            return true;
        }
        if (key.equals("libspath")) {
            configure.setLibsPath(value);
            return true;
        }
        if (key.equals("depends")) {
            configure.setDependsString(value);
            return true;
        }
        if (key.equals("libs")) {
            configure.setLibs(value);
            return true;
        }
        if (key.equals("links")) {
            configure.setLinks(value);
            return true;
        }
        if (key.equals("incspath")) {
            configure.setIncsPath(value);
            return true;
        }
        if (key.equals("outfile")) {
            if (value.indexOf("$(Output)") != -1) {
                return false;
            }
            configure.setOption("outname", value);
            return true;
        }
        if (key.equals("cmd")) {
            configure.setOption("cmd", value);
            return true;
        }
        if (key.equals("acmd")) {
            configure.setOption("acmd", value);
            return true;
        }
        if (key.equals("arglist")) {
            configure.setOption("args", value);
            return true;
        }
        if (key.equals("workdir")) {
            configure.setOption("workdir", value);
            return true;
        }
        if (key.equals("makebuild")) {
            configure.setOption("makebuild", value);
            return true;
        }
        if (key.equals("makeclean")) {
            configure.setOption("makeclean", value);
            return true;
        }
        if (key.equals("prebuild")) {
            configure.setOption("prebuild", value);
            return true;
        }
        if (key.equals("afterbuild")) {
            configure.setOption("afterbuild", value);
            return true;
        }
        if (key.equals("preclean")) {
            configure.setOption("preclean", value);
            return true;
        }
        if (key.equals("afterclean")) {
            configure.setOption("afterclean", value);
            return true;
        }
        if (key.equals("ignorew")) {
            if (value.equals("启用(-w)")) {
                configure.setOption("ignorewarning", "-w");
            } else {
                configure.setOption("ignorewarning", "");
            }

            return true;
        }
        if (key.equals("ignorewl")) {
            configure.setOption(key, value);
            return true;
        }
        if (key.equals("debuginfo")) {
            if (value.equals("禁用(-nd)")) {
                configure.setOption("debugdatabase", "-nd");
            } else {
                configure.setOption("debugdatabase", "");
            }
            return true;
        }
        if (key.equals("debugable")) {
            if (value.equals("禁用(nilptr)")) {
                configure.setOption("debugable", "");
            } else {
                configure.setOption("debugable", "-dbg");
            }
            return true;
        }
        if (key.equals("compdest")) {
            if (value.equals("禁用(nilptr)")) {
                configure.setOption("compdest", "");
            } else {
                configure.setOption("compdest", "-z");
            }
            return true;
        }
        if (key.equals("warnilptr") || key.equals("warexcp")) {
            configure.setOption(key, value);
            return true;
        }
        return true;
    }

    public String getValue(@NotNilptr Project object, @NotNilptr Configure configure, @NotNilptr String key)override {
        if (key.equals("projname")) {
            return object.getName();
        }
        if (key.equals("icofile")) {
            return object.getOption(key);
        }
        if (key.equals("versioninc")) {
            return object.getOption(key);
        }
        if (key.equals("uaclevel")) {
            String type =  configure.getOption(key);
            if (type.equals("管理员(-uac-admin)")) {
                return "1";
            }
            if (type.equals("最高级别(-uac-highest)")) {
                return "2";
            }
            return "0";
        }
        if (key.equals("projtype")) {
            String type = configure.getOption("command");
            if (type.equals("-ce")) {
                return "1";
            }
            if (type.equals("-c")) {
                return "0";
            }
            if (type.equals("-lix -c")) {
                return "2";
            }
            if (type.equals("-slx -c")) {
                return "3";
            }
            if (type.equals("-xl -c")) {
                return "4";
            }
            return "未知";
        }
        if (key.equals("wtype")) {
            String type = configure.getOption("wtype");
            if (type.equals("")) {
                return "0";
            }
            if (type.equals("-arch:x86")) {
                return "1";
            }
            if (type.equals("-arch:x86_64")) {
                return "2";
            }
            if (type.equals("-arch:arm")) {
                return "3";
            }
            if (type.equals("-arch:arm64")) {
                return "4";
            }
            if (type.equals("-arch:mips")) {
                return "5";
            }
            return type;
        }
        if (key.equals("ostype")) {
            String type = configure.getOption("ostype");
            if (type.equals("")) {
                return "0";
            }
            if (type.equals("-xcross-windows")) {
                return "1";
            }
            if (type.equals("-xcross-linux")) {
                return "2";
            }
            if (type.equals("-xcross-darwin")) {
                return "3";
            }
            return type;
        }
        if (key.equals("sstype")) {
            String type = configure.getOption("sstype");
            if (type.equals("")) {
                return "0";
            }
            if (type.equals("-console")) {
                return "1";
            }
            return type;
        }
        if (key.equals("libspath")) {
            return configure.getLibsPath();
        }
        if (key.equals("depends")) {
            return configure.getDependsString();
        }
        if (key.equals("libs")) {
            return configure.getLibs();
        }
        if (key.equals("links")) {
            return configure.getLinks();
        }
        if (key.equals("incspath")) {
            return configure.getIncsPath();
        }
        if (key.equals("projout")) {
            return configure.getOption("outpath");
        }
        /*if (key.equals("deploypath")){
            return configure.getOption("deploypath");
        }*/
        if (key.equals("outfile")) {
            return configure.getOption("outname");
        }
        if (key.equals("cmd")) {
            return configure.getOption("cmd");
        }
        if (key.equals("acmd")) {
            return configure.getOption("acmd");
        }
        if (key.equals("arglist")) {
            return configure.getOption("args");
        }
        if (key.equals("workdir")) {
            return configure.getOption("workdir");
        }
        if (key.equals("makebuild")) {
            return configure.getOption(key);
        }
        if (key.equals("makeclean")) {
            return configure.getOption(key);
        }
        if (key.equals("prebuild")) {
            return configure.getOption(key);
        }
        if (key.equals("afterbuild")) {
            return configure.getOption(key);
        }
        if (key.equals("preclean")) {
            return configure.getOption(key);
        }
        if (key.equals("afterclean")) {
            return configure.getOption(key);
        }
        if (key.equals("ignorewl")) {
            return configure.getOption(key);
        }
        if (key.equals("ignorew")) {
            String options = configure.getOption("ignorewarning");
            if (options.equals("-w")) {
                return "0";
            } else {
                return "1";
            }
        }
        if (key.equals("debuginfo")) {
            String options = configure.getOption("debugdatabase");
            if (options.equals("-nd")) {
                return "1";
            } else {
                return "0";
            }
        }
        if (key.equals("compdest")) {
            String options = configure.getOption("compdest");
            if (options.equals("-z")) {
                return "0";
            } else {
                return "1";
            }
        }

        if (key.equals("debugable")) {
            String options = configure.getOption("debugable");
            if (options.equals("-dbg")) {
                return "0";
            } else {
                return "1";
            }
        }
        if (key.equals("warnilptr") || key.equals("warexcp")) {
            return configure.getOption(key);
        }
        return "";
    }
    public bool testOptions(@NotNilptr String options, @NotNilptr String opt) {
        String[] opts = options.split(' ');
        for (int i = 0; i < opts.length; i++) {
            /*_system_.consoleWrite(opts[i] + " matched " + opt + "\n");*/
            if (opts[i].equals(opt)) {
                return true;
            }
        }
        return false;
    }

   public  void generateCommand(@NotNilptr Configure configure,@NotNilptr  Vector<String> sourceArgs) {
        String cmd = configure.getOption("command");
        String []cmds = cmd.split(' ');
        for (int i =0; i < cmds.length; i++) {
            sourceArgs.add(cmds[i]);
        }
    }

   public  static void makefile(@NotNilptr IBuilder builder,@NotNilptr  Project object,@NotNilptr  Configure configure,@NotNilptr  String projectDir) {
        String [] margs = {"make"};

        String args = configure.getOption("makebuild");
        args = XEnvironment.MapVariable(object, configure, args);
        if (args.length() > 0) {
            Vector<String> arglist = processArgs(args);
            if (arglist.size() > 0) {
                String []argmake = new String[arglist.size() + 1];
                argmake[0] = "make";
                for (int i = 0; i < arglist.size(); i++) {
                    argmake[1 + i] = arglist.get(i);
                }
                margs = argmake;
            }
        }

        Process _mprocess = new Process("/usr/bin/make", margs);
        _mprocess.setWorkDirectory(projectDir);

        String statusoutput = "/usr/bin/make " + args;

        builder.OutputText(statusoutput + "\n", 0);

        try {
            if (_mprocess.create(Process.StdOut | Process.RedirectStdErr)) {
                Utils.readForProcess(builder, _mprocess);
                _mprocess.waitFor(-1);
            } else {
                builder.OutputText("\nmakefile失败.\n", 0);
            }

        } catch(Exception e) {
            String str = e.getMessage();
            builder.OutputText("\n错误:" + str + "\n", 0);
        }
    }

    public void makefile_clean(@NotNilptr IBuilder builder,@NotNilptr  Project object, @NotNilptr Configure configure, @NotNilptr String projectDir) {
        String [] margs = {"make", "clean"};

        String args = configure.getOption("makeclean");
        args = XEnvironment.MapVariable(object, configure, args);
        if (args.length() > 0) {
            Vector<String> arglist = processArgs(args);
            if (arglist.size() > 0) {
                String []argmake = new String[arglist.size() + 1];
                argmake[0] = "make";
                for (int i = 0; i < arglist.size(); i++) {
                    argmake[1 + i] = arglist.get(i);
                }
                margs = argmake;
            }
        }

        Process _mprocess = new Process("/usr/bin/make", margs);
        _mprocess.setWorkDirectory(projectDir);

        String statusoutput = "/usr/bin/make " + args;

        builder.OutputText(statusoutput + "\n", 0);

        try {
            if (_mprocess.create(Process.StdOut | Process.RedirectStdErr)) {
                Utils.readForProcess(builder, _mprocess);
                _mprocess.waitFor(-1);
            } else {
                builder.OutputText("\nmakefile失败.\n", 0);
            }

        } catch(Exception e) {
            String str = e.getMessage();
            builder.OutputText("\n错误:" + str + "\n", 0);
        }
    }

    public static class BuildParams {
        public bool forgs;
        public String output_source;
    };

    public void IncrementVersionSection(@NotNilptr String [] section, int id) {

        int verval = section[id].parseInt() + 1;

        if (verval > 65535 && id > 0) {
            IncrementVersionSection(section, id - 1);
            verval = 0;
        }
        section[id] = "" + verval;
    }

    public void versionIncrement(@NotNilptr IBuilder builder,@NotNilptr String file) {
        try {
            FileInputStream fis = new FileInputStream(file);
            byte [ ] data = fis.read();
            fis.close();

            String str = new String(data);

            JsonObject root = new JsonObject(str);

        
            String filever = root.getString("FileVersion");
            if (filever == nilptr) {
                filever = root.getString("ProductVersion");
            }
            if (filever != nilptr) {
                String []versec = filever.split('.');

                IncrementVersionSection(versec, versec.length - 1);

                filever = "";
                for (int i = 0; i < versec.length; i ++) {
                    if (i != 0) {
                        filever =  filever + "." + versec[i];
                    } else {
                        filever = filever + versec[i];
                    }
                }

                root.remove("FileVersion");
                root.put("FileVersion", filever);

                root.remove("ProductVersion");
                root.put("ProductVersion", filever);


                XWorkspace.workspace.qfsw.removePath(file);

                FileOutputStream fos = new FileOutputStream(file);
                fos.write(root.toString(true).getBytes());
                fos.close();

                XWorkspace.workspace.qfsw.addPath(file);

                builder.OutputText("修订版本为:" + filever + "\n", 0);
            }
        
        } catch(Exception e) {
            builder.OutputText("修订版本时发生异常:" + e.getMessage() + "\n", 0);
        }
    }

    public @NotNilptr Vector<String> getSourceArgs(@NotNilptr IBuilder builder,@NotNilptr  Project object, @NotNilptr Configure configure, @NotNilptr String workDir, BuildParams param) {
        Vector<String> sourceArgs = new Vector<String>();
        String compiler_path = getCompilerPath();

        if (_system_.getPlatformId() == 0) {
            sourceArgs.add("\"" + compiler_path + "\"");
        } else {
            sourceArgs.add(compiler_path);
        }

        if (param == nilptr) {
            generateCommand(configure, sourceArgs);
        } else {
            sourceArgs.add("-gs");
        }

        bool fixver = object.getOption("versioninc").equals("1");

        JsonArray sources = object.getSources();
        
        if (sources != nilptr){
            if (_system_.getPlatformId() == 0) { /* windows */
                for (int i = 0; i < sources.length(); i++) {
                    String srcname = sources.getString(i);
                    if (srcname != nilptr){
                        String ext = srcname.findExtension();
                        //String fname = srcname.findFilenameAndExtension();

                        String fullsourcePath = String.formatPath(workDir.appendPath(srcname), false);
                        if (ext.equalsIgnoreCase(".x") || ext.equalsIgnoreCase(".xcs") || ext.equalsIgnoreCase(".xcsm") || ext.equalsIgnoreCase(".version") || ext.equalsIgnoreCase(".xdef")) {
                            if (fixver) {
                                if (ext.equalsIgnoreCase(".version")) {
                                    versionIncrement(builder, fullsourcePath);
                                }
                            }
                            String source = "\"" + fullsourcePath + "\" ";
                            sourceArgs.add(source);
                        }
                    }
                }
            } else {
                for (int i = 0; i < sources.length(); i++) {
                    String srcname = sources.getString(i);
                    if (srcname != nilptr){
                        String ext = srcname.findExtension();
                        String fname = srcname.findFilenameAndExtension();

                        String fullsourcePath = String.formatPath(workDir.appendPath(srcname), false);
                        
                        
                        if (fname.equalsIgnoreCase("makefile")) {
                            makefile(builder, object, configure, workDir);
                        }
                        if (ext.equalsIgnoreCase(".x") || ext.equalsIgnoreCase(".xcs") || ext.equalsIgnoreCase(".xcsm") || ext.equalsIgnoreCase(".version")) {
                            if (fixver) {
                                if (ext.equalsIgnoreCase(".version")) {
                                    versionIncrement(builder, fullsourcePath);
                                }
                            }
                            sourceArgs.add(fullsourcePath);
                        }
                    
                    }
                }
            }
        }

        return sourceArgs;
    }

    public static String getArch(@NotNilptr Configure configure) {
        String [] archs = {"unknow", "x86", "x64", "arm", "arm64", "mips"};

        String arch = configure.getOption("wtype");
        if (arch.equals("")) {
            int aid = _system_.getArchId();

            if (aid < 0 || aid > 5) {
                aid = 0;
            }
            return archs[aid];

        } else {
            if (arch.equals("-arch:x86")) {
                return archs[1];
            } else if (arch.equals("-arch:x86_64")) {
                return archs[2];
            } else if (arch.equals("-arch:arm")) {
                return archs[3];
            } else if (arch.equals("-arch:arm64")) {
                return archs[4];
            } else if (arch.equals("-arch:mips")) {
                return archs[5];
            } else {
                if (arch.length() > 6) {
                    return arch.substring(6,arch.length());
                }
                return arch;
            }
        }
    }

    public @NotNilptr String getArchArgs(@NotNilptr Configure configure) {
        /*String [] archs = {"", "-arch:x86", "-arch:x86_64", "-arch:arm", "-arch:arm64", "-arch:mips"};

        String arch = configure.getOption("wtype");*/
        /*if (arch.equals("")){
        	int aid = _system_.getArchId();

            if (aid <= 0 || aid > 5){
        		aid = 1;
            }
            return archs[aid];
        }*/

        return configure.getOption("wtype");
    }

    public @NotNilptr String getXcrossName(@NotNilptr Configure configure) {
        String [] archs = {"", "-xcross-windows", "-xcross-linux", "-xcross-darwin"};

        String arch = configure.getOption("ostype");
        if (arch.equals("") == false) {

            int aid = _system_.getArchId();

            if (aid <= 0 || aid > 3) {
                aid = 1;
            }
            return archs[aid + 1];

        } else {
            return arch;
        }
    }

    public @NotNilptr String map_variable(@NotNilptr Project object,@NotNilptr  Configure configure,@NotNilptr  String text) override{
        text = text.replace("$(Output)", configure.getOption("outpath").appendPath(configure.getOption("outname")));
        text = text.replace("$(Configure)", configure.getName());
        text = text.replace("$(Arch)", getArch(configure));

        String ptype = configure.getOption("command");
        String ostype = configure.getOption("ostype");

        String ext = "";

        if (ptype.equals("-ce")) {
            if ((ostype.length() == 0 && _system_.getPlatformId() == 0) || ostype.equalsIgnoreCase("-xcross-windows")) {
                ext = ".exe";
            }
        } else if (ptype.equals("-lix -c")) {
            ext = ".lix";
        } else if (ptype.equals("-slx -c")) {
            ext = ".slx";
        } else if (ptype.equals("-xl -c")) {
            ext = ".xl";
        } else if (ptype.equals("-c")) {
            ext = ".exc";
        }


        text = text.replace("$(Ext)", ext);

        return text;
    }

    public void generateJsonArrayArgs(@NotNilptr String key, JsonArray incpath,@NotNilptr Vector<String> args) {
        //String incs = "";
        if (incpath == nilptr){
            return;
        }
        
        bool pushkey = false;
        for (int i = 0; i < incpath.length(); i++) {
            String inc = incpath.getString(i);
            if (inc != nilptr && inc.length() > 0) {
                if (pushkey == false) {
                    args.add(key);
                    pushkey = true;
                }
                if (_system_.getPlatformId() == 0) {
                    args.add("\"" + inc + "\"");
                } else {
                    args.add(inc);
                }
            }
        }
    }

    public void generateJsonArrayArgsMake(JsonArray incpath,@NotNilptr Vector<String> args) {
        //String incs = "";
        if (incpath == nilptr){
            return;
        }
        
        bool pushkey = false;
        for (int i = 0; i < incpath.length(); i++) {
            String inc = incpath.getString(i);
            if (inc != nilptr && inc.length() > 0) {
                if (inc.indexOf(' ') != -1) {
                    args.add("\"" + inc + "\"");
                } else {
                    args.add(inc);
                }
            }
        }
    }

    public void generateWarning(@NotNilptr Configure configure,@NotNilptr Vector<String> args) {
        String values = configure.getOption("ignorewl");
        if (values.length() != 0) {
            args.add("-wl");
            String [] vals = values.split(';');
            for (int i = 0; i < vals.length; i++) {
                args.add(vals[i]);
            }
        }
    }

    public void generatePathForMake(@NotNilptr Configure configure,@NotNilptr Vector<String> args) {
        if (configure.root == nilptr) {
            return ;
        }

        JsonObject paths = (JsonObject)configure.root.get("path");
        if (paths != nilptr) {
            JsonArray incpath = (JsonArray)paths.get("incpath");
            JsonArray libpath = (JsonArray)paths.get("libpath");
            generateJsonArrayArgsMake(incpath, args);
            generateJsonArrayArgsMake(libpath, args);
        }
    }

    public void generateLibsForMake(@NotNilptr Configure configure,@NotNilptr Vector<String> args,@NotNilptr Vector<String> linkarg) {
        if (configure.root == nilptr) {
            return ;
        }

        JsonArray libs = (JsonArray)configure.root.get("libs");
        generateJsonArrayArgsMake(libs, args);

        JsonArray links = (JsonArray)configure.root.get("links");
        generateJsonArrayArgsMake(links, linkarg);
    }

    public void generatePath(@NotNilptr Configure configure,@NotNilptr Vector<String> args) {
        if (configure.root == nilptr) {
            return ;
        }

        JsonObject paths = (JsonObject)configure.root.get("path");
        if (paths != nilptr) {
            JsonArray incpath = (JsonArray)paths.get("incpath");
            JsonArray libpath = (JsonArray)paths.get("libpath");
            if (incpath != nilptr){
                generateJsonArrayArgs("-incpath", incpath, args);
            }
            if (libpath != nilptr){
                generateJsonArrayArgs("-libpath", libpath, args);
            }
        }
    }

    public void generateLibs(@NotNilptr Configure configure,@NotNilptr Vector<String> args) {
        if (configure.root == nilptr) {
            return ;
        }

        JsonArray libs = (JsonArray)configure.root.get("libs");
        generateJsonArrayArgs("-lib", libs, args);

        JsonArray links = (JsonArray)configure.root.get("links");
        generateJsonArrayArgs("-link", links, args);
    }


    public void checkOptions(Vector<String> args,Map<String,String> argmap,@NotNilptr Configure configure,@NotNilptr String []key) {
        for (int i =0; i < key.length; i++) {
            String option = configure.getOption(key[i]);

            if (option.length() > 0) {
                if (args != nilptr) {
                    args.add(option);
                }
                if (argmap != nilptr) {
                    argmap.put(key[i], option);
                }

            } else if (key[i].equals("wtype")) {
                String wtype = getArchArgs(configure);
                if (wtype.length() > 0) {
                    if (args != nilptr) {
                        args.add(wtype);
                    }
                    if (argmap != nilptr) {
                        argmap.put(key[i], wtype);
                    }
                }
            } else if (key[i].equals("ostype")) {
                String ostype = getXcrossName(configure);
                if (ostype.length() > 0) {
                    if (args != nilptr) {
                        args.add(ostype);
                    }
                    if (argmap != nilptr) {
                        argmap.put(key[i], ostype);
                    }
                }
            } else if (key[i].equals("sstype")) {
                String sstype = configure.getOption("sstype");
                if (sstype.length() > 0) {
                    if (args != nilptr) {
                        args.add(sstype);
                    }
                    if (argmap != nilptr) {
                        argmap.put(key[i], sstype);
                    }
                }
            }
        }
    }


    public @NotNilptr String getMapValue(@NotNilptr Map<String,String> args,@NotNilptr String key) {
        Map.Iterator<String,String> iter = args.find(key);
        String value = nilptr;
        if (iter != nilptr) {
            value = iter.getValue();
        }
        if (value == nilptr){
            value = "";
        }
        return value;
    }

    public @NotNilptr String getVectorPath(@NotNilptr Vector<String> libs,@NotNilptr String key) {
        String output = "";
        for (int i =0; i < libs.size(); i++) {
            output = output + " " + libs.get(i);
        }
        if (output.length() > 0) {
            return key + output;
        }

        return output.replace("\\", "/");
    }

    public String generateMake(@NotNilptr Project object, @NotNilptr Configure configure) {

        String workdir = object.projpath.findVolumePath();

        String file = _system_.getAppDirectory();
        file = file.appendPath("config").appendPath(object.getLanguage() + ".mk");

        String template;

        try {
            FileInputStream fis = new FileInputStream(file);
            byte [] data = fis.read();
            template = new String(data);
            fis.close();
        } catch(Exception e) {
            return nilptr;
        }

        Vector<String> libs = new Vector<String>();
        Vector<String> links = new Vector<String>();
        Vector<String> paths = new Vector<String>();

        Map<String,String> args = new Map<String,String>();

        String []options = {"ignorewarning", "debugdatabase", "debugable", "wtype", "ostype", "sstype","compdest", "warnilptr", "warexcp"};

        checkOptions(nilptr, args, configure, options);

        //路径变量
        generatePathForMake(configure, paths);

        //外部库
        generateLibsForMake(configure, libs, links);

        args.put("acmd",XEnvironment.MapVariable(object, configure, configure.getOption("acmd")));

        String uac = configure.getOption("uaclevel");
        if (uac.length() > 0) {
            if (uac.equals("管理员(-uac-admin)")) {
                args.put("uac", "-uac-admin");
            } else if (uac.equals("最高级别(-uac-highest)")) {
                args.put("uac", "-uac-highest");
            }
        }

        String icofile = object.getOption("icofile");

        if (icofile.length() > 0) {
            icofile = XEnvironment.MapVariable(object, configure, icofile).replace("\\", "/");
            if (icofile.lastIndexOf(' ') != -1) { /* windows */
                args.put("ico", "\"" + icofile + "\"");
            } else {
                args.put("ico", icofile);
            }
        }

        args.put("output",String.formatPath(XEnvironment.MapVariable(object, configure, configure.getOption("outpath").appendPath(configure.getOption("outname"))), false)
                 .toRelativePath(workdir, false, true)
                 .replace("\\", "/"));

        JsonArray sources = object.getSources();

        String sourcesText = "";

        String warning_dis = configure.getOption("ignorewl");
        warning_dis = warning_dis.trim(true).replace(";"," ");

        String command = configure.getOption("command");
        if (sources != nilptr){
            for (int i = 0, c = sources.length(); i < c; i++) {
                String srcname = sources.getString(i);
                if (srcname != nilptr){
                    String ext = srcname.findExtension();
                    String fname = srcname.findFilenameAndExtension();

                    String fullsourcePath = String.formatPath(workdir.appendPath(srcname), false);

                    fullsourcePath = fullsourcePath.toRelativePath(workdir, false, true).replace("\\", "/");

                    if ((ext.equalsIgnoreCase(".x") ||ext.equalsIgnoreCase(".xcs") || ext.equalsIgnoreCase(".xcsm") || ext.equalsIgnoreCase(".version")) ) {
                        if (fullsourcePath.indexOf(' ') != -1) {
                            fullsourcePath = "\"" + fullsourcePath + "\"";
                        }
                        if (sourcesText.length() != 0) {
                            sourcesText = sourcesText + " \\\n\t" + fullsourcePath;
                        } else {
                            sourcesText = fullsourcePath;
                        }
                    }
                }
            }
        }

        String xflags = getMapValue(args, "ignorewarning") + " " +
                        getMapValue(args, "debugdatabase") +  " " +
                        getMapValue(args, "debugable") +  " " +
                        getMapValue(args, "compdest") +  " " +
                        getMapValue(args, "uac") +  " " +
                        getMapValue(args, "acmd");

        String output = getMapValue(args, "output");

        String icocmd = getMapValue(args, "ico");

        if (warning_dis.length() > 0) {
            xflags = xflags + " -wl " + warning_dis;
        }

        if (icocmd.length() > 0) {
            xflags = xflags + " -ico " + icocmd;
        }

        String xcross = getMapValue(args, "wtype") +  " " +
                        getMapValue(args, "ostype");

        String pathtext = getVectorPath(paths, "-libpath");

        String statictext = getVectorPath(libs, "-lib");

        String lxtext = getVectorPath(links, "-lx");

        return template.replace("${XFLAGS}", xflags)
               .replace("${PLATFORM_ARCH}", xcross)
               .replace("${OUTPUT}", output)
               .replace("${LIBPATH}", pathtext)
               .replace("${LX}", lxtext)
               .replace("${LIBS}", statictext)
               .replace("${SOURCES}", sourcesText)
               .replace("${CMD}", command);
    }

    public String [] generateBuildArgs(@NotNilptr Vector<String> __args,@NotNilptr Project object,@NotNilptr Configure configure, BuildParams param) {
        Vector<String> args = new Vector<String>();

        String []options = {"ignorewarning", "debugdatabase", "debugable", "wtype", "ostype", "sstype", "compdest" , "warnilptr", "warexcp"};

        checkOptions(args, nilptr, configure, options);

        //路径变量
        generateWarning(configure, args);

        //路径变量
        generatePath(configure, args);

        //外部库
        generateLibs(configure, args);

        String acmd = XEnvironment.MapVariable(object, configure, configure.getOption("acmd"));

        if (acmd.length() > 0) {
            Vector<String> amcds = processArgs(acmd);
            for (int i =0; i < amcds.size(); i++) {
                args.add(amcds.get(i));
            }
        }

        String uac = configure.getOption("uaclevel");
        if (uac.length() > 0) {
            if (uac.equals("管理员(-uac-admin)")) {
                args.add("-uac-admin");
            } else if (uac.equals("最高级别(-uac-highest)")) {
                args.add("-uac-highest");
            }
        }

        String icofile = object.getOption("icofile");

        if (icofile.length() > 0) {
            args.add("-ico");
            icofile = XEnvironment.MapVariable(object, configure, icofile);
            if (_system_.getPlatformId() == 0) { /* windows */
                args.add("\"" + icofile + "\"");
            } else {
                args.add(icofile);
            }
        }

        args.add("-o");

        String out_path = configure.getOption("outpath");

        if (param != nilptr) {
            out_path = param.output_source;
            if (_system_.getPlatformId() == 0) { /* windows */
                args.add("\"" + out_path + "\"");
            } else {
                args.add(out_path);
            }
        } else {

            out_path = String.formatPath(XEnvironment.MapVariable(object, configure, out_path), false);
            mkdirs(out_path);

            if (_system_.getPlatformId() == 0) { /* windows */
                args.add("\"" + out_path.appendPath(configure.getOption("outname")) + "\"");
            } else {
                args.add(out_path.appendPath(configure.getOption("outname")));
            }
        }
        String [] szArgs = new String[args.size() + __args.size()];

        int argpos = 0;

        for (int i = 0, c = __args.size(); i < c; i++) {
            String zrgitem = __args.get(i);
            if (zrgitem != nilptr){
                szArgs[argpos++] = XPlatform.converToPlatformCharSet(zrgitem);
            }
        }

        for (int i = 0, c = args.size(); i < c; i++) {
            String argitem = args.get(i);
            if (argitem != nilptr){
                szArgs[argpos++] = XPlatform.converToPlatformCharSet(XEnvironment.MapVariable(object, configure, argitem));
            }
        }

        return szArgs;
    }



    public static bool mkdirs(String path) {
        if (path != nilptr){
            if (XPlatform.existsSystemFile(path) == false) {
                if (XPlatform.mkdir(path) == false) {
                    mkdirs(path.findVolumePath());
                    return XPlatform.mkdir(path);
                }
            }
        }
        return true;
    }

    public int detectInfo(@NotNilptr String line) {
        if (line.endWith(warning)) {
            return ICompileInfo.WARNING;
        }
        if (line.endWith(error)) {
            return ICompileInfo.ERROR;
        }
        if (line.endWith(tips)) {
            return ICompileInfo.TIPS;
        }
        return -1;
    }

    public @NotNilptr Vector<ICompileInfo> parseInfo(@NotNilptr String info) {
        Vector<ICompileInfo> infos = new Vector<ICompileInfo>();
        String [] list = info.split("\n");
    
        for (int i = 0; i < list.length; i++) {
            String message = list[i].trim(true);
            int t = detectInfo(message);
            if (t != -1) {
                String tips_block = message;
                i++;
                for (; i < list.length; i++) {
                    if (list[i].startWith(" ")) {
                        tips_block = tips_block + "\n" + list[i];
                    } else {
                        i--;
                        break;
                    }
                }
                infos.add(new CompileInfo(message, t, tips_block));
            }
        }
    
        return infos;
    }

    public static String formatArgs(@NotNilptr String param) {
        if (_system_.getPlatformId() == 0) {
            if (param.indexOf(" ") != -1 && param.startWith("\"") == false && param.endWith("\"") == false ) {
                return "\"" + param + "\"";
            }
        }
        return param;
    }
    
    public JsonArray getExternLibs(@NotNilptr Configure cfg){
        try{
            JsonArray ja =  (JsonArray)cfg.root.get("libs");
            return ja;
        }catch(Exception e){
            
        }
        return nilptr;
    }
    
    public void cleanup(@NotNilptr IBuilder builder,@NotNilptr  Project object,@NotNilptr  Configure configure)override {
        batchbuild(builder, object, configure, "preclean");

        String workdir = object.projpath.findVolumePath();
        
    
        JsonArray sources = object.getSources();

        if (sources != nilptr && _system_.getPlatformId() != 0) { /* linux unix */
            for (int i = 0, c = sources.length(); i < c; i++) {
                String srcname = sources.getString(i);

                if (srcname != nilptr){
                    String fname = srcname.findFilenameAndExtension();

                    if (fname.equalsIgnoreCase("makefile")) {
                        makefile_clean(builder, object, configure, workdir);
                    }
                }
            }
        }
    
        String target = getTarget(object, configure);
        builder.OutputText(target + "... \n", 0);
    
        if (XPlatform.existsSystemFile(target)) {
            if (false == XPlatform.deleteFile(target)) {
                builder.OutputText("文件正在使用中,清理失败\n", 0);
            }
        }
    
        batchbuild(builder, object, configure, "afterclean");
    }



    public static void runbat(@NotNilptr IBuilder builder,@NotNilptr String batfile, String projectDir) {
        String [] margs = {"cmd", "/c", formatArgs(batfile)};

        String execute = XKernel32.getWindowsDir();
        if (execute == nilptr) {
            return;
        }

        execute = String.formatPath( execute.appendPath("system32\\cmd.exe"), false);
        Process _mprocess = new Process(execute, margs);
        _mprocess.setWorkDirectory(projectDir);

        String statusoutput = "bat scripts " + batfile;

        builder.OutputText(statusoutput + "\n", 0);

        try {
            if (_mprocess.create(Process.StdOut | Process.RedirectStdErr)) {
                Utils.readForProcess(builder, _mprocess);
                _mprocess.waitFor(-1);
            } else {
                builder.OutputText("\n build scripts失败.\n", 0);
            }

        } catch(Exception e) {
            String str = e.getMessage();
            builder.OutputText("\n错误:" + XPlatform.converPlatformCharSetTo(str) + "\n", 0);
        }
    }

    public static void runsh(@NotNilptr IBuilder builder, String shfile, String projectDir) {
        String [] margs = {"bash", "-c", shfile};
        Process _mprocess = new Process("/bin/bash", margs);
        _mprocess.setWorkDirectory(projectDir);

        String statusoutput = "bash scripts " + shfile;

        builder.OutputText(statusoutput + "\n", 0);

        try {
            if (_mprocess.create(Process.StdOut | Process.RedirectStdErr)) {
                Utils.readForProcess(builder, _mprocess);
                _mprocess.waitFor(-1);
            } else {
                builder.OutputText("\n build scripts失败.\n", 0);
            }

        } catch(Exception e) {
            String str = e.getMessage();
            builder.OutputText("\n错误:" + XPlatform.converPlatformCharSetTo(str) + "\n", 0);
        }
    }

    public static void batchbuild(@NotNilptr IBuilder builder,@NotNilptr  Project object,@NotNilptr  Configure configure,@NotNilptr  String key) {
        String workdir = object.projpath.findVolumePath();

        String txt = configure.getOption(key);

        if (txt.length() == 0) {
            return;
        }

        String batfile = XEnvironment.MapVariable(object, configure, txt);

        int osid = _system_.getPlatformId();

        if (osid == 0) {
            runbat(builder, batfile, workdir);
        } else {
            runsh(builder, batfile, workdir);
        }
    }


    bool buildConfigure(@NotNilptr IBuilder builder,@NotNilptr  Project object,@NotNilptr  Configure configure, Object param){
        String workdir = object.projpath.findVolumePath();
        
        String allInfo = "";
        
        String target = getTarget(object, configure);

        if (XPlatform.existsSystemFile(target)) {
            if (false == XPlatform.deleteFile(target)) {
                builder.OutputText("无法删除文件:" + target + " ,文件正在使用中\n", 0);
                return false;
            }
        }
        
        batchbuild(builder, object, configure, "prebuild");
        
        Vector<String> _args = getSourceArgs(builder, object, configure, workdir, (BuildParams)param);
        
        String []args = generateBuildArgs(_args, object, configure, (BuildParams)param);
        
        allInfo = allInfo + builder.build(getCompilerPath(), args, workdir, nilptr, false);
        
        builder.setCompileInfor(parseInfo(allInfo));
        
        batchbuild(builder, object, configure, "afterbuild");
        
        return true;
    }
    
    public bool build(@NotNilptr IBuilder builder,@NotNilptr  Project object,Configure configure, Object param)override {
        if (configure == nilptr) {
            Map.Iterator<String, Configure> iter = object.configures.iterator();
            while (iter.hasNext()) {
                Configure conf = iter.getValue();
                if (conf != nilptr){
                    buildConfigure(builder, object, conf, param);
                }
                iter.next();
            }
        } else {
            buildConfigure(builder, object, configure, param);
        }
        builder.complete();
        return true;
    }
    
    public void stopRun()override {
        synchronized(process_lock){
            if (process != nilptr) {
                process.exit(0); 
                _system_.sleep(80);
            } 
        }
    }

    public @NotNilptr static String getTarget(@NotNilptr Project object,@NotNilptr  Configure configure) {
        String out_path = XEnvironment.MapVariable(object, configure, "$(Output)");
        return String.formatPath(out_path, false);
    }

    public String getExecuteCmd(@NotNilptr Project object,@NotNilptr  Configure configure) {
        String out_path = configure.getOption("cmd");
        out_path = XEnvironment.MapVariable(object, configure, out_path);
        return String.formatPath(out_path, false);
    }
    
    public @NotNilptr String getExecuteWd(@NotNilptr Project object,@NotNilptr  Configure configure) {
        String out_path = configure.getOption("workdir");
        out_path = XEnvironment.MapVariable(object, configure, out_path);
        return String.formatPath(out_path, false);
    }

    public @NotNilptr static Vector<String> processArgs(@NotNilptr String args) {
        Vector<String> args_list = new Vector<String>();
        byte []data = args.getBytes();

        int start = 0;
        bool inline = false;

        for (int i = 0; i < data.length; i++) {
            if (data[i] == '"') {
                inline = !inline;
            }
            if (inline == false) {
                if (data[i] == ' ' || data[i] == '\r' || data[i] == '\n' || data[i] == '\t' ) {
                    data[i] = ' ';
                    if (i > start){
                        args_list.add(new String(data, start, i - start));
                    }
                    start = i + 1;
                }
            }
        }

        if (start < data.length) {
            String arg = new String(data, start, data.length - start);
            args_list.add(arg);
        }

        return args_list;
    }

    public @NotNilptr Vector<String> getExecuteArgs(@NotNilptr Project object, @NotNilptr Configure configure) {

        String out_path = configure.getOption("args");
        Vector<String> argve = processArgs(out_path);

        Vector<String> finalargs = new Vector<String>();

        for (int i = 0, c  = argve.size(); i < c; i++) {
            String argval = argve.get(i);
            if (argval != nilptr){
                finalargs.add(formatArgs(String.formatPath(XEnvironment.MapVariable(object, configure, argval), false)));
            }
        }

        return finalargs;
    }

    public int getDebugSerial() {
        if (XDEBUG_SERIAL == 0) {
            XDEBUG_SERIAL = Process.getId() * 100;
        } else {
            XDEBUG_SERIAL++;
        }
        return XDEBUG_SERIAL;
    }


    public bool checkDebugFlag(@NotNilptr String path) {
        long hf = XPlatform.openSystemFile(path, "r");
        if (hf == 0) {
            return false;
        }

        bool bret = false;

        _system_.seekFile(hf, Stream.SeekEnd, -4);

        byte[] flag = new byte[4];
        if (4 == _system_.readFile(hf, flag, 0, 4)) {
            if (flag[0] == 'x' && flag[1] == 'd' && flag[2] == 'b'&& flag[3] == 'g') {
                bret = true;
            }
        }
        _system_.closeFile(hf);

        return bret;
    }

    
    
    public Stream createDebugPipe(String host, int port)override{
        return nilptr;
    }
    
    public Stream getDebugPipe(){
        return _debug_pipe;
    }
    
     
    public void customDebug(){
        
    }
    
    public String getDebuggeeDescription()override{
        return "XLANG Debugger (xlang 专用调试器)";
    }
    
    public void debugRun(@NotNilptr IBuilder builder,@NotNilptr  Project proj,@NotNilptr  Configure conf)override {
        if (XWorkspace.isDebugging()) {
            builder.OutputText("\调试器已在运行中,请等待当前调试工作结束.\n", 0);
            return ;
        }
        int debugSerial = getDebugSerial();

        String exePath = getExecuteCmd(proj, conf);/*getBuildFile(proj, conf);*/
        if (exePath == nilptr){
            builder.OutputText("\n没有找到目标程序", 0);
            return;
        }
        if (_system_.getPlatformId() != 2) {
            if (checkDebugFlag(exePath) == false) {
                if (XPlatform.existsSystemFile(exePath) == false) {
                    builder.OutputText("\n没有找到目标程序:" + exePath + ",请先编译生成.\n", 0);
                    XWorkspace.workspace.executeNotExists();
                } else {
                    builder.OutputText("\n目标程序:" + exePath + "不支持调试,请在[项目]->[属性]->[编译选项]中开启调试后重新编译\n", 0);
                    XWorkspace.workspace.notSupportDebug();
                }

                return ;
            }
        }
        Vector<String> args = getExecuteArgs(proj, conf);
        args.add("-xdbg:" + debugSerial);

        String []args__ = nilptr;

        if (args.size() > 0) {
            args__ = new String[args.size()];
            for (int i = 0; i < args__.length; i++) {
                String argval = args.get(i);
                if (argval != nilptr){
                    args__[i] = XPlatform.converToPlatformCharSet(argval);
                }
            }
        }

        
            Process debug_process = new Process(XPlatform.converToPlatformCharSet(exePath), args__);
            debug_process.setWorkDirectory(XPlatform.converToPlatformCharSet(getExecuteWd(proj, conf)));

            String statusoutput = "\n运行: " + exePath + " ";

            for (int i = 0, c = args.size(); i < c; i++) {
                statusoutput = statusoutput + args.get(i) + " ";
            }

            builder.OutputText(statusoutput + "\n", 0);
            XDebugPipe _xp = new XDebugPipe(debugSerial);
            
            if (_xp.prepareForPipe() == false){
                builder.OutputText("\n无法创建调试端口!\n", 1);
                return ;
            }else{
                _debug_pipe = _xp;
            }
            try {
                if (XWorkspace.workspace.debugPrepare(getDebugPipe())) {
                    bool readforstdout = Setting.isRelocalStdout();
                    if (debug_process.create(readforstdout ? (Process.StdOut | Process.RedirectStdErr) : Process.Visible)) {
                        builder.OutputText("\n已创建进程 ID: " + debug_process.id() + "\n", 0);
                        
                        if (_xp.createstream() == false || XWorkspace.workspace.debug() == false) {
                            builder.OutputText("\n调试器失败.\n", 0);
                            debug_process.exit(0);
                        }
                        
                        synchronized(process_lock){
                            process = debug_process;
                        }
                        
                        if (readforstdout) {
                            Utils.readForProcess(builder, debug_process);
                        }
                        debug_process.waitFor(-1);
                        //XWorkspace.workspace.debugClose();
                        builder.OutputText("\n退出代码: " + debug_process.getExitCode() + "\n", 0);
                        
                        synchronized(process_lock){
                            process = nilptr;
                        }
                    } else {

                        builder.OutputText("\n运行失败.\n", 0);
                    }
                } else {
                    builder.OutputText("\n调试器正忙.\n", 0);
                }
            } catch(Exception e) {

                if (e.getErrorCode() == 0x000002E4) {
                    XWorkspace.workspace.runOnUi(new Runnable() {
                        void run()override {
                            if (QXMessageBox.Question("注意", "被调试程序需要提升权限, 是否重新以提升的权限运行?", QXMessageBox.Ok | QXMessageBox.Cancel, QXMessageBox.Ok) == QXMessageBox.Ok) {
                                XWorkspace.runAsAdministrator();
                            }
                        }
                    });
                }

                String str = e.getMessage();

                if (_system_.getPlatformId() == 0) {
                    builder.OutputText("\n错误:" + new String(str.getBytes(), "GB18030//IGNORE") + "\n", 0);
                } else {
                    builder.OutputText("\n错误:" + str + "\n", 0);
                }
            }
            finally{
                XWorkspace.workspace.debugClose();
            }
        
    }

    public void Run(@NotNilptr IBuilder builder,@NotNilptr  Project proj,@NotNilptr  Configure conf)override {

        String exePath = getExecuteCmd(proj, conf);/*getBuildFile(proj, conf);*/

        if (exePath == nilptr || XPlatform.existsSystemFile(exePath) == false) {
            builder.OutputText("\n没有找到目标程序:" + exePath + ",请先编译生成.\n", 0);
            return ;
        }

        Vector<String> args = getExecuteArgs(proj, conf);

        String []args__ = nilptr;

        if (args.size() > 0) {
            args__ = new String[args.size()];
            for (int i =0; i < args__.length; i++) {
                String argval = args.get(i);
                if (argval != nilptr){
                    args__[i] = XPlatform.converToPlatformCharSet(argval);
                }
            }
        }

        Process debug_process = new Process(XPlatform.converToPlatformCharSet(exePath), args__);
        debug_process.setWorkDirectory(XPlatform.converToPlatformCharSet(getExecuteWd(proj, conf)));

        builder.OutputText("\n运行: " + exePath + "\n", 0);

        try {
            bool readforstdout = Setting.isRelocalStdout();
            if (debug_process.create(readforstdout ? (Process.StdOut | Process.RedirectStdErr) : Process.Visible)) {
                synchronized(process_lock){
                    process = debug_process;
                }
                if (readforstdout) {
                    Utils.readForProcess(builder, debug_process);
                }
                debug_process.waitFor(-1);
                builder.OutputText("\n退出代码: " + debug_process.getExitCode() + "\n", 0);
                synchronized(process_lock){
                    process = nilptr;
                }
            } else {
                builder.OutputText("\n运行失败.\n", 0);
            }
        } catch(Exception e) {
            String str = e.getMessage();
            if (_system_.getPlatformId() == 0) {
                builder.OutputText("\n错误:" + new String(str.getBytes(), "GB18030//IGNORE") + "\n", 0);
            } else {
                builder.OutputText("\n错误:" + str + "\n", 0);
            }
        }
    }
    public IXPlugin getXPlugin()override{
       return nilptr;
    }
    public static bool copyFile(@NotNilptr String source, @NotNilptr String dest) {
        if (XPlatform.existsSystemFile(source)) {
            try {
                FileOutputStream fos = new FileOutputStream(dest);
                fos.write(new FileInputStream(source).read());
                fos.close();
                return true;
            } catch(Exception e) {

            }
        }
        return false;
    }


    public bool createZTemplateProject(@NotNilptr WizardLoader loader,@NotNilptr String projectName,@NotNilptr  String projectDir,@NotNilptr  String uuid) {
        XPlatform.mkdir(projectDir);

        String confFile = XPlatform.getAppDirectory().appendPath("config").appendPath(uuid + ".utemp");

        String destProj = projectDir.appendPath(projectName + ".xprj");

        if (extartToDir(confFile, projectDir, projectName)) {
            generateProjectFile(destProj, projectName);
        }

        IProject _project = loader.loadProject(destProj);
        if (uuid.equals("0ef0fe5d-5ab9-4d62-ab6a-ee78f059ad1e") || uuid.equals("5e5ab583-973f-41cd-98cb-ac5208557f8b")){
            if (_project != nilptr){
                _project.importPackage("Qt5.9.1", nilptr);
            }
        }
        return true;
    }

    public bool createExampleProject(@NotNilptr WizardLoader loader,@NotNilptr String projectName,@NotNilptr String projectDir,@NotNilptr  String localFile) {
        XPlatform.mkdir(projectDir);

        String projectFile = extartExampleToDir(localFile,projectDir,".xprj");

        if (projectFile != nilptr) {
            loader.loadProject(projectFile);
            return true;
        }
        return false;
    }

    public void copyQtLibs(@NotNilptr String projectDir) {
        String source = XPlatform.getAppDirectory().appendPath("lib").appendPath("QXLibrary.lix");
        String dest = projectDir.appendPath("libs").appendPath("QXLibrary.lix");
        copyFile(source, dest);

        source = XPlatform.getAppDirectory().appendPath("lib").appendPath("x86").appendPath("QXLibrary.dll");
        dest = projectDir.appendPath("x86").appendPath("debug").appendPath("QXLibrary.dll");
        copyFile(source, dest);

        source = XPlatform.getAppDirectory().appendPath("lib").appendPath("x86_64").appendPath("QXLibrary.dll");
        dest = projectDir.appendPath("x64").appendPath("debug").appendPath("QXLibrary.dll");
        copyFile(source, dest);

        source = XPlatform.getAppDirectory().appendPath("lib").appendPath("x86").appendPath("QXLibrary.so");
        dest = projectDir.appendPath("x86").appendPath("debug").appendPath("QXLibrary.so");
        copyFile(source, dest);

        source = XPlatform.getAppDirectory().appendPath("lib").appendPath("x86_64").appendPath("QXLibrary.so");
        dest = projectDir.appendPath("x64").appendPath("debug").appendPath("QXLibrary.so");
        copyFile(source, dest);

        source = XPlatform.getAppDirectory().appendPath("lib").appendPath("x86_64").appendPath("QXLibrary.dylib");
        dest = projectDir.appendPath("x64").appendPath("debug").appendPath("QXLibrary.dylib");
        copyFile(source, dest);
    }

    /*bool generateLibs(String projectDir, String uuid) {
        String [] qtprojs = {"0ef0fe5d-5ab9-4d62-ab6a-ee78f059ad1e", "5e5ab583-973f-41cd-98cb-ac5208557f8b"};

        for (int i =0; i < qtprojs.length; i++) {
            if (qtprojs[i].equals(uuid)) {
                copyQtLibs(projectDir);
                break;
            }
        }

        return true;
    }*/

    public bool generateProjectFile(@NotNilptr String destFile,@NotNilptr  String projectName) {
        try {
            FileInputStream fis = new FileInputStream(destFile);
            byte [] data = fis.read();
            String content = new String(data);
            content = content.replace("${ProjectName}", projectName);
            fis.close();

            FileOutputStream fos = new FileOutputStream(destFile);
            byte [] odata = content.getBytes();
            fos.write(odata);
            fos.close();
        } catch(Exception e) {
            return false;
        }
        return true;
    }


    public bool createNormalProject(@NotNilptr WizardLoader loader,@NotNilptr String projectName,@NotNilptr  String projectDir,@NotNilptr  String uuid) {
        XPlatform.mkdir(projectDir);
        String confFile = "./config/" + uuid + ".prop";
        String destProj = String.formatPath(projectDir.appendPath(projectName + ".xprj"), false);
        try {
            FileInputStream fis = new FileInputStream(confFile);
            byte [] data = fis.read();
            String content = new String(data);
            content = content.replace("${ProjectName}", projectName);


            FileOutputStream fos = new FileOutputStream(destProj);
            byte [] odata = content.getBytes();
            fos.write(odata);
            fos.close();
            String mainFile = projectDir.appendPath(projectName + ".x");
            fos = new FileOutputStream(mainFile);
            String out_class = 	"//xlang " +
                                "\npackage System{" +
                                "\n	public class out{" +
                                "\n		public static int println(String text){"	+
                                "\n			return _system_.consoleWrite(text + \"\\n\");" +
                                "\n		}"	+
                                "\n		public static int print(String text){"	+
                                "\n			return _system_.consoleWrite(text);" +
                                "\n		}"	+
                                "\n	};" +
                                "\n};" +
                                "\n\n" +
                                "\nusing { System; };"	+
                                "\n\n" +
                                "\nint main(String [] args){"	+
                                "\n\n	System.out.println(\"hello world\");" +
                                "\n\n	_system_.sleep(3000);"	+
                                "\n\n	return 0;"	+
                                "\n}\n";

            fos.write(out_class.getBytes());
            fos.close();
        } catch(Exception e) {
            return false;
        }
        loader.loadProject(destProj);
        return true;
    }

    public bool extartToDir(@NotNilptr String zfile,@NotNilptr  String dir,@NotNilptr  String projName) {

        FileInputStream fis;

        try {
            fis = new FileInputStream(zfile);
        } catch(Exception e) {
            return false;
        }

        bool bSuccess = true;
        ZipArchive zs = new ZipArchive();
        if (zs.open(fis)) {
            int c = zs.getEntriesCount();
            for (int i =0; i < c; i ++) {
                ZipEntry entry = zs.getEntry(i);
                if (bSuccess == false) {
                    break;
                }
                if (entry != nilptr){
                    String entryName = entry.getName();
                    entryName = entryName.replace("${ProjectName}", projName);

                    String path = String.formatPath(dir.appendPath(entryName), false);

                    if (entry.isDirectory() == false) {
                        ZipFile file = entry.getFile();

                        byte []buf = new byte[1024];
                        int rd = 0;
                        if (file.open()) {
                            long filehandler = XPlatform.openSystemFile(path, "w");
                            if (filehandler != 0) {
                                while ((rd = file.read(buf, 0, 1024)) != 0) {
                                    _system_.writeFile(filehandler, buf, 0, rd);
                                }
                                _system_.closeFile(filehandler);
                            } else {
                                bSuccess = false;
                            }
                            file.close();
                        } else {
                            bSuccess = false;
                        }
                    } else {
                        XPlatform.mkdir(path);
                    }
                }
            }
            zs.close();
        } else {
            bSuccess = false;
        }

        return bSuccess;
    }

    public String  extartExampleToDir(@NotNilptr String zfile,@NotNilptr  String dir, @NotNilptr String extsion) {

        String projectName = nilptr;

        FileInputStream fis;

        try {
            fis = new FileInputStream(zfile);
        } catch(Exception e) {
            return nilptr;
        }

        bool bSuccess = true;
        ZipArchive zs = new ZipArchive();
        if (zs.open(fis)) {
            int c = zs.getEntriesCount();
            for (int i =0; i < c; i ++) {
                ZipEntry entry = zs.getEntry(i);
                if (bSuccess == false) {
                    break;
                }
                
                if (entry != nilptr){
                    String entryName = entry.getName();
                    String extision = entryName.findExtension();
                    if (extision.equalsIgnoreCase(extsion)) {
                        projectName = String.formatPath(dir.appendPath(entryName), false);
                    }
                    //entryName = entryName.replace("${ProjectName}", projName);

                    String path = String.formatPath(dir.appendPath(entryName), false);

                    if (entry.isDirectory() == false) {
                        ZipFile file = entry.getFile();

                        byte []buf = new byte[1024];
                        int rd = 0;
                        if (file.open()) {
                            long filehandler = XPlatform.openSystemFile(path, "w");
                            if (filehandler != 0) {
                                while ((rd = file.read(buf, 0, 1024)) != 0) {
                                    _system_.writeFile(filehandler, buf, 0, rd);
                                }
                                _system_.closeFile(filehandler);
                            } else {
                                bSuccess = false;
                            }
                            file.close();
                        } else {
                            bSuccess = false;
                        }
                    } else {
                        XPlatform.mkdir(path);
                    }
                }
            }
            zs.close();
        } else {
            projectName = nilptr;
        }

        return projectName;
    }

    public byte [] getContentForNewFile(@NotNilptr String filename,Project project, @NotNilptr String uuid) {

        String projectName = "XApp";
        if (project != nilptr) {
            projectName = project.getName();
        }

        if (uuid.equals("f55e671c-d2fe-4414-b060-fac629ccda6d")) {
            //ui
            String default_content = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                                     "<ui version=\"4.0\">" +
                                     " <class>MainWindow</class>" +
                                     " <widget class=\"QMainWindow\" name=\"MainWindow\">" +
                                     "  <property name=\"geometry\">" +
                                     "   <rect>" +
                                     "    <x>0</x>" +
                                     "    <y>0</y>" +
                                     "    <width>719</width>" +
                                     "    <height>545</height>" +
                                     "   </rect>" +
                                     "  </property>" +
                                     "  <property name=\"windowTitle\">" +
                                     "   <string>MainWindow</string>" +
                                     "  </property>" +
                                     "  <widget class=\"QWidget\" name=\"centralwidget\"/>" +
                                     "  <widget class=\"QMenuBar\" name=\"menubar\">" +
                                     "   <property name=\"geometry\">" +
                                     "    <rect>" +
                                     "     <x>0</x>" +
                                     "     <y>0</y>" +
                                     "     <width>719</width>" +
                                     "     <height>23</height>" +
                                     "    </rect>" +
                                     "   </property>" +
                                     "  </widget>" +
                                     "  <widget class=\"QStatusBar\" name=\"statusbar\"/>" +
                                     " </widget>" +
                                     " <resources/>" +
                                     " <connections/>" +
                                     "</ui>";
            return default_content.getBytes();
        } else if (uuid.equals("f48d4411-6b02-4f8b-a961-23a2e079c55c")) {
            // version
            JsonObject json = new JsonObject();
            json.put("FileVersion","1.0.0.0");
            json.put("ProductVersion", "1.0.0.0");

            json.put("ProductName", projectName);
            json.put("InternalName", projectName + ".exe");

            json.put("CompanyName", "XStudio");
            json.put("LegalCopyright", "Copyright (C) 2018 X-Studio");

            json.put("FileDescription", projectName);
            return json.toString(true).getBytes();
        } else if (uuid.equals("ddd530a0-1573-44b7-9f6c-06642e3151ad")) {
            // version
            JsonObject json = new JsonObject();
            json.put("library",  projectName + ".slx");

            JsonArray export_def = new JsonArray();

            export_def.put("MyClass.subClass");
            export_def.put("MyClass1");

            JsonArray hidden_def = new JsonArray();

            hidden_def.put("MyClass2.subClass");
            hidden_def.put("MyClass3");

            json.put("exports",export_def);
            json.put("hidden",hidden_def);

            return json.toString(true).getBytes();
        }

        String date = String.formatDate("%c", _system_.currentTimeMillis());
        return ("//xlang Source, Name:" + filename + " \n" + "//Date: " + date + " \n").getBytes();

    }
    
    public IXIntelliSense allocIntelliSense(@NotNilptr Project project,@NotNilptr  Configure cfg){
        return new XIntelliSense(project, cfg);
    }
    
    public bool createNormalFileToProject(@NotNilptr WizardLoader loader,@NotNilptr String projectName, @NotNilptr String projectDir, @NotNilptr String uuid, Project ownProject, bool addToProject, String ext) {
        XPlatform.mkdir(projectDir);
        try {
            String extsion = projectName.findExtension();
            String filename ;
            if (extsion.length() > 0) {
                filename = projectName;
            } else {
                filename = projectName + ext;
            }
            
            String destProj = String.formatPath(projectDir.appendPath(filename), false);

            if (XPlatform.existsSystemFile(destProj)) {
                if (QXMessageBox.Question("注意", destProj + "<a style=\"color:#ffff0000\">继续建立新文件将改写原有文件?</a>", QXMessageBox.Ok | QXMessageBox.No, QXMessageBox.Ok) == QXMessageBox.No) {
                    return false;
                }
            }
            if (ownProject != nilptr){
                FileOutputStream fos = new FileOutputStream(destProj);
                
                fos.write(getContentForNewFile(filename, ownProject, uuid));
                fos.close();
                loader.openTextFile(destProj);
                if (addToProject) {
                    return ownProject.addSource(destProj);
                }
            }
            return true;
        } catch(Exception e) {

        }
        return false;
    }
    
    public ICompileInfo parseOutputLine(@NotNilptr QXSci sci, int position, int line,@NotNilptr  String lineText){
        int pos = lineText.lastIndexOf('(');
        bool succeed = false;
        try{
            if (pos != -1) {
                int lp = lineText.indexOf(':', pos);
                if (lp != -1 && (lp + 1) < lineText.length()) {
                    int le = lineText.indexOf(',', lp);
                    int rp = lineText.indexOf(':', lp + 1);
                    if (rp != -1 && le != -1) {
                        int re = lineText.indexOf(')', lp);
                        if (re != -1){
                            String file = lineText.substring(0, pos).trim(true);
                            int tl = lineText.substring(lp + 1, le).parseInt();
                            int tr = lineText.substring(rp + 1, re).parseInt();


                            int i = line + 1;
                            String infos = lineText;

                            for (int c = sci.countOfLine(); i < c; i++) {
                                String linestr = sci.getText(i);

                                if (linestr.startWith(" ") == false) {
                                    break;
                                } else {
                                    infos = infos + "\n" + linestr ;
                                }
                            }
                            /*if (infos.length() < 5){
                                infos = nilptr;
                            }*/
                            return new CompileInfo(file, tl, tr, infos);
                        }
                    }
                }
            }
        }catch(Exception e){
            
        }
        if (succeed == false){
            pos = lineText.indexOf(':', 3);
            if (pos != -1) {
                try{
                    String file = lineText.substring(0, pos).trim(true);
                    int tl = lineText.substring(pos + 1, lineText.length()).parseInt();
                    
                    int i = line + 1;
                    String infos = lineText;

                    for (int c = sci.countOfLine(); i < c; i++) {
                        String linestr = sci.getText(i);

                        if (linestr.startWith(" ") == false) {
                            break;
                        } else {
                            infos = infos + "\n" + linestr ;
                        }
                    }
                    
                    return new CompileInfo(file, tl, 1, infos);
                }catch(Exception e){
                    
                }
            }
        }
        
        return nilptr;
    }
    public void stopBuild(IBuilder builder)override{
        
    }
    public bool create(@NotNilptr WizardLoader loader,@NotNilptr  String projectName,@NotNilptr  String projectDir, @NotNilptr String uuid, Project ownProject, bool addToProject, String userType)override {

        if (userType != nilptr && userType.equals("project")) {
            if (Pattern.test(projectName, "^[A-Za-z0-9_]+$", Pattern.NOTEMPTY, true) == false) {
                QXMessageBox.Critical("错误", "项目名称不合法", QXMessageBox.Ok, QXMessageBox.Ok);
                return false;
            }
            String priject_dir = String.formatPath(projectDir.appendPath(projectName), false);
            if (XPlatform.existsSystemFile(priject_dir)) {
                QXMessageBox.Critical("错误", "该位置已存在同名项目, 请重新选择路径或者改变项目名", QXMessageBox.Ok, QXMessageBox.Ok);
                return false;
            } else {
                if (mkdirs(priject_dir) == false) {
                    QXMessageBox.Critical("错误", "无法在此位置建立新目录, 请重新选择路径", QXMessageBox.Ok, QXMessageBox.Ok);
                    return false;
                }
            }
            return createZTemplateProject(loader, projectName, priject_dir, uuid);
        }

        if (uuid.equals("100911ae-27e8-4479-a56f-af015358f1a6")) {
            if (Pattern.test(projectName, "^[A-Za-z0-9_]+$", Pattern.NOTEMPTY, true) == false) {
                QXMessageBox.Critical("错误", "项目名称不合法", QXMessageBox.Ok, QXMessageBox.Ok);
                return false;
            }
            String priject_dir = String.formatPath(projectDir.appendPath(projectName), false);
            if (XPlatform.existsSystemFile(priject_dir)) {
                QXMessageBox.Critical("错误", "该位置已存在同名项目, 请重新选择路径或者改变项目名", QXMessageBox.Ok, QXMessageBox.Ok);
                return false;
            } else {
                if (mkdirs(priject_dir) == false) {
                    QXMessageBox.Critical("错误", "无法在此位置建立新目录, 请重新选择路径", QXMessageBox.Ok, QXMessageBox.Ok);
                    return false;
                }
            }
            return createNormalProject(loader, projectName, priject_dir, uuid);
        }

        if (uuid.equals("76d637db-bbaa-4a4f-907b-84d3a8cc15a2") ||
            uuid.equals("e5787cae-9900-4c41-9eb5-08e61cfc0fb2")	||
            uuid.equals("651c2524-d9a5-40e9-b6cf-3d480bc75631") ||
            uuid.equals("0ef0fe5d-5ab9-4d62-ab6a-ee78f059ad1e") ||
            uuid.equals("85384b44-719b-4aaa-8c8b-ad5ecec4201b") ||
            uuid.equals("5e5ab583-973f-41cd-98cb-ac5208557f8b") ||
            uuid.equals("48791fab-9225-4baf-a3e4-fe10f2d48a55") ||
            uuid.equals("917e553d-0008-49db-83ca-d601b92c9ff3") ||
            uuid.equals("710fa396-4acd-4c78-bfaa-4ee7362702e1")) 
        {

            if (Pattern.test(projectName, "^[A-Za-z0-9_]+$", Pattern.NOTEMPTY, true) == false) {
                QXMessageBox.Critical("错误", "项目名称不合法", QXMessageBox.Ok, QXMessageBox.Ok);
                return false;
            }
            String priject_dir = String.formatPath(projectDir.appendPath(projectName), false);
            if (XPlatform.existsSystemFile(priject_dir)) {
                QXMessageBox.Critical("错误", "该位置已存在同名项目, 请重新选择路径或者改变项目名", QXMessageBox.Ok, QXMessageBox.Ok);
                return false;
            } else {
                if (mkdirs(priject_dir) == false) {
                    QXMessageBox.Critical("错误", "无法在此位置建立新目录, 请重新选择路径", QXMessageBox.Ok, QXMessageBox.Ok);
                    return false;
                }
            }
            return createZTemplateProject(loader, projectName, priject_dir, uuid);
        }
        if (uuid.equals("c54f477d-4d91-464f-88db-d462cce8bc12")) {
            return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".x");
        }
        if (uuid.equals("262b6f61-478a-4968-b800-1f22520ef0bf")) {
            return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".xcs");
        }
        if (uuid.equals("8f95f230-7662-4543-9495-6f7cd083c2b9")) {
            return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".xcsm");
        }
        if (uuid.equals("f55e671c-d2fe-4414-b060-fac629ccda6d")) {
            return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".ui");
        }
        if (uuid.equals("f48d4411-6b02-4f8b-a961-23a2e079c55c")) {
            return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".version");
        }
        if (uuid.equals("ddd530a0-1573-44b7-9f6c-06642e3151ad")) {
            return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".xdef");
        }
        if (userType != nilptr && userType.equals("example")) {
            String priject_dir = String.formatPath(projectDir.appendPath(projectName), false);
            return createExampleProject(loader, projectName, priject_dir, uuid);
        }
        return false;
    }
};
