
class XlangProjectProp : ProjectPropInterface{

    static const String _compile_path = ("bin/xcross.exe");
	static const String _compile_path_linux = ("bin/xcross");
    
    static const String warning = "警告:";
    static const String error = "错误:";
    static const String tips = "提示:";

	int XDEBUG_SERIAL = 0;
    
    Process process ;
    static class CompileInfo : ICompileInfo{
        String file;
        int line;
        int row;
        int type;
        String tip;
        CompileInfo(String s, int l,int r){
            
        }
        
        CompileInfo(String text, int t, String _tips){
            int pos = text.lastIndexOf("(");
            int rpos = text.lastIndexOf(")");
            if (pos != -1 && rpos != -1){
            
                file = text.substring(0, pos);
                String linerow = text.substring(pos + 1, rpos);
                
                String []lr = linerow.split(',');
                if (lr.length == 2){
                
                        int m = lr[0].indexOf(':');
                        
                        if (m != -1){
                            line = lr[0].substring(m + 1, lr[0].length()).parseInt();
                        }
                        
                        m = lr[1].indexOf(':');
                        
                        if (m != -1){
                            row = lr[1].substring(m + 1, lr[1].length()).parseInt();
                        }
                }
                
                if (_tips != nilptr){
					byte [] tipdata = _tips.getBytes();
                    try{
						tip = new String(tipdata, "CP936");
                    }catch(Exception e){
						tip = new String(tipdata);
                    }
                }
                type = t;
            }else{
                type = -1;
            }
        }
        
        int getType()override{
            return type;
        }
        String getFile()override{
            return file;
        }
        int getLine()override{
            return line;
        }
        int getRow()override{
            return row;
        }
        String getTips(){
			return tip;
        }
    };


	static String getCompilerPath(){
		String workDir = _system_.getAppDirectory();
		if (_system_.getPlatformId() == 0){
			return workDir.appendPath(_compile_path);
		}
		return workDir.appendPath(_compile_path_linux);
	}

    bool setValue(Project object, Configure configure,  String key, String value)override{
        if (key.equals("projname")){
            return true;
        }
        if (key.equals("icofile")){
			object.setOption(key, value);
            return true;
        }
        if (key.equals("versioninc")){
            if (value.equals("启用")){
                object.setOption("versioninc", "1");
            }else{
                object.setOption("versioninc", "0");
            }
            return true;
        }
        if (key.equals("uaclevel")){
			configure.setOption(key, value);
            return true;
        }
        if (key.equals("projtype")){
            if (value.equals("xlang 可执行文件(-c)")){
                configure.setOption("command", "-c");
                return true;
            }
            if (value.equals("可执行文件(-ce)")){
                configure.setOption("command", "-ce");
                return true;
            }
            if (value.equals("xlang 静态链接库(-lix -c)")){
                configure.setOption("command", "-lix -c");
                return true;
            }
            return false;
        }
        if (key.equals("wtype")){
			if (value.equals("当前开发环境")){
				configure.setOption("wtype", "");
            }else{
				configure.setOption("wtype", value);
            }
			return true;
        }
        if (key.equals("ostype")){
			if (value.equals("当前操作系统")){
				configure.setOption("ostype", "");
            }else{
				configure.setOption("ostype", value);
            }
			return true;
        }
        if (key.equals("projout")){
			if (value.indexOf("$(Output)") != -1){
				return false;
            }
            configure.setOption("outpath", value);
            return true;
        }
        if (key.equals("libspath")){
            configure.setLibsPath(value);
            return true;
        }
        if (key.equals("libs")){
            configure.setLibs(value);
            return true;
        }
        if (key.equals("incspath")){
            configure.setIncsPath(value);
            return true;
        }
        if (key.equals("outfile")){
        	if (value.indexOf("$(Output)") != -1){
				return false;
            }
            configure.setOption("outname", value);
            return true;
        }
        if (key.equals("cmd")){
            configure.setOption("cmd", value);
            return true;
        }
        if (key.equals("arglist")){
            configure.setOption("args", value);
            return true;
        }
        if (key.equals("workdir")){
            configure.setOption("workdir", value);
            return true;
        }
        if (key.equals("makebuild")){
            configure.setOption("makebuild", value);
            return true;
        }
        if (key.equals("makeclean")){
            configure.setOption("makeclean", value);
            return true;
        }
        if (key.equals("prebuild")){
            configure.setOption("prebuild", value);
            return true;
        }
        if (key.equals("afterbuild")){
            configure.setOption("afterbuild", value);
            return true;
        }
        if (key.equals("preclean")){
            configure.setOption("preclean", value);
            return true;
        }
        if (key.equals("afterclean")){
            configure.setOption("afterclean", value);
            return true;
        }
        if (key.equals("ignorew")){
            if (value.equals("启用(-w)")){
                configure.setOption("ignorewarning", "-w");
            }else{
                configure.setOption("ignorewarning", "");
            }
            
            return true;
        }
        if (key.equals("debuginfo")){
            if (value.equals("禁用(-nd)")){
                configure.setOption("debugdatabase", "-nd");
            }else{
                configure.setOption("debugdatabase", "");
            }
            return true;
        }
        if (key.equals("debugable")){
            if (value.equals("禁用(nilptr)")){
                configure.setOption("debugable", "");
            }else{
                configure.setOption("debugable", "-dbg");
            }
            return true;
        }
        return true;
    }
        
    String getValue(Project object, Configure configure,  String key)override{
        if (key.equals("projname")){
            return object.getName();
        }        
        if (key.equals("icofile")){
            return object.getOption(key);
        }
        if (key.equals("versioninc")){
            return object.getOption(key);
        }
        if (key.equals("uaclevel")){
			String type =  configure.getOption(key);
            if (type.equals("管理员(-uac-admin)")){
				return "1";
            }
            if (type.equals("最高级别(-uac-highest)")){
				return "2";
            }
            return "0";
        }
        if (key.equals("projtype")){
            String type = configure.getOption("command");
            if (type.equals("-ce")){
                return "1";
            }
            if (type.equals("-c")){
                return "0";
            }
            if (type.equals("-lix -c")){
                return "2";
            }
            return "未知";
        }
        if (key.equals("wtype")){
            String type = configure.getOption("wtype");
            if (type.equals("")){
                return "0";
            }
            if (type.equals("-arch:x86")){
                return "1";
            }
            if (type.equals("-arch:x86_64")){
                return "2";
            }
            if (type.equals("-arch:arm")){
                return "3";
            }
            if (type.equals("-arch:arm64")){
                return "4";
            }
            if (type.equals("-arch:mips")){
                return "5";
            }
            return "未知";
        }
        if (key.equals("ostype")){
            String type = configure.getOption("ostype");
            if (type.equals("")){
                return "0";
            }
            if (type.equals("-xcross-windows")){
                return "1";
            }
            if (type.equals("-xcross-linux")){
                return "2";
            }
            if (type.equals("-xcross-darwin")){
                return "3";
            }
            return "未知";
        }
        if (key.equals("libspath")){
            return configure.getLibsPath();
        }
        if (key.equals("libs")){
            return configure.getLibs();
        }
        if (key.equals("incspath")){
            return configure.getIncsPath();
        }
        if (key.equals("projout")){
            return configure.getOption("outpath");
        }
        if (key.equals("outfile")){
            return configure.getOption("outname");
        }
        if (key.equals("cmd")){
            return configure.getOption("cmd");
        }
        if (key.equals("arglist")){
            return configure.getOption("args");
        }
        if (key.equals("workdir")){
            return configure.getOption("workdir");
        }
        if (key.equals("makebuild")){
            return configure.getOption(key);
        }
        if (key.equals("makeclean")){
            return configure.getOption(key);
        }
        if (key.equals("prebuild")){
            return configure.getOption(key);
        }
        if (key.equals("afterbuild")){
            return configure.getOption(key);
        }
        if (key.equals("preclean")){
            return configure.getOption(key);
        }
        if (key.equals("afterclean")){
            return configure.getOption(key);
        }
        if (key.equals("ignorew")){
            String options = configure.getOption("ignorewarning");
            if (options != nilptr && options.equals("-w")){
                return "0";
            }else{
                return "1";
            }
        }
        if (key.equals("debuginfo")){
            String options = configure.getOption("debugdatabase");
            if (options != nilptr && options.equals("-nd")){
                return "1";
            }else{
                return "0";
            }
        }
        if (key.equals("debugable")){
            String options = configure.getOption("debugable");
            if (options != nilptr && options.equals("-dbg")){
                return "0";
            }else{
                return "1";
            }
        }      

        return "";
    }
    bool testOptions(String options, String opt){
        String[] opts = options.split(' ');
        for (int i = 0; i < opts.length; i++){
            /*_system_.consoleWrite(opts[i] + " matched " + opt + "\n");*/
            if (opts[i].equals(opt)){
                return true;
            }
        }
        return false;
    }
    
    void generateCommand(Configure configure, Vector<String> sourceArgs){
		String cmd = configure.getOption("command");
        String []cmds = cmd.split(' ');
        for (int i =0; i < cmds.length; i++){
			sourceArgs.add(cmds[i]);
        }
    }
    
    void makefile(IBuilder builder, Project object, Configure configure, String projectDir){
		String [] margs = {"make"};
        
		String args = configure.getOption("makebuild");
		args = map_variable(object, configure, args);
		if (args != nilptr && args.length() > 0){
			 Vector<String> arglist = processArgs(args);
             if (arglist.size() > 0){
				String []argmake = new String[arglist.size() + 1];
                argmake[0] = "make";
                for (int i = 0; i < arglist.size(); i++){
					argmake[1 + i] = arglist.get(i);
                }
                margs = argmake;
             }
        }
        
		Process _mprocess = new Process("/usr/bin/make", margs);
        _mprocess.setWorkDirectory(projectDir);
        
        String statusoutput = "/usr/bin/make " + args;
            
        builder.OutputText(statusoutput + "\n");
        
        try{
			if (_mprocess.create(false, true, false, false)){
				Utils.readForProcess(builder, _mprocess);
				_mprocess.waitFor(-1);
			}else{
				builder.OutputText("\nmakefile失败.\n");
			}

        }catch(Exception e){
			String str = e.getMessage();
			builder.OutputText("\n错误:" + str + "\n");
        }
    }
    
    void makefile_clean(IBuilder builder, Project object, Configure configure, String projectDir){
		String [] margs = {"make", "clean"};
        
		String args = configure.getOption("makeclean");
		args = map_variable(object, configure, args);
		if (args != nilptr && args.length() > 0){
			 Vector<String> arglist = processArgs(args);
             if (arglist.size() > 0){
				String []argmake = new String[arglist.size() + 1];
                argmake[0] = "make";
                for (int i = 0; i < arglist.size(); i++){
					argmake[1 + i] = arglist.get(i);
                }
                margs = argmake;
             }
        }
        
		Process _mprocess = new Process("/usr/bin/make ", margs);
        _mprocess.setWorkDirectory(projectDir);
        
        String statusoutput = "/usr/bin/make" + args;
            
        builder.OutputText(statusoutput + "\n");
        
        try{
			if (_mprocess.create(false, true, false, false)){
				Utils.readForProcess(builder, _mprocess);
				_mprocess.waitFor(-1);
			}else{
				builder.OutputText("\nmakefile失败.\n");
			}

        }catch(Exception e){
			String str = e.getMessage();
			builder.OutputText("\n错误:" + str + "\n");
        }
    }
    
    static class BuildParams{
		bool forgs;
        String output_source;
    };
    
    void IncrementVersionSection(String [] section, int id){

		int verval = section[id].parseInt() + 1;
		
		if (verval > 65535 && id > 0){
			IncrementVersionSection(section, id - 1);
            verval = 0;
		}
        section[id] = "" + verval;
    }
    
    void versionIncrement(IBuilder builder, String file){
		try{
			FileInputStream fis = new FileInputStream(file);
            byte [ ] data = fis.read();
            fis.close();
            
            String str = new String(data);
            
            JsonObject root = new JsonObject(str);
            
            if (root != nilptr){
				String filever = root.getString("FileVersion");
                if (filever == nilptr){
					filever = root.getString("ProductVersion");
                }
                if (filever != nilptr){
					String []versec = filever.split('.');
                    
                    IncrementVersionSection(versec, versec.length - 1);
                    
                    filever = "";
					for (int i = 0; i < versec.length; i ++){
						if (i != 0){
							filever =  filever + "." + versec[i];
                        }else{
							filever = filever + versec[i];
                        }
                    }
                    
                    root.remove("FileVersion");
                    root.put("FileVersion", filever);
                    
                    root.remove("ProductVersion");
                    root.put("ProductVersion", filever);
                    
                    
                    XWorkspace.workspace.qfsw.removePath(file);
                    
                    FileOutputStream fos = new FileOutputStream(file);
                    fos.write(root.toString(true).getBytes());
                    fos.close();
                    
                    XWorkspace.workspace.qfsw.addPath(file);
                    
                    builder.OutputText("修订版本为:" + filever + "\n");
                }
            }
		}catch(Exception e){
			builder.OutputText("修订版本时发生异常:" + e.getMessage() + "\n");
		}
    }
    
    Vector<String> getSourceArgs(IBuilder builder, Project object, Configure configure, String workDir, BuildParams param){
		Vector<String> sourceArgs = new Vector<String>();
        String compiler_path = getCompilerPath();

		if (_system_.getPlatformId() == 0){
			sourceArgs.add("\"" + compiler_path + "\"");
		}else{
			sourceArgs.add(compiler_path);
		}
		
        if (param == nilptr){
			generateCommand(configure, sourceArgs);
        }else{
			sourceArgs.add("-gs");
        }
        
		bool fixver = object.getOption("versioninc").equals("1");
        
        JsonArray sources = object.getSources();
		if (_system_.getPlatformId() == 0){ /* windows */
			for (int i = 0; i < sources.length(); i++){
				String srcname = sources.getString(i);
                String ext = srcname.findExtension();
                String fname = srcname.findFilenameAndExtension();
                
                String fullsourcePath = String.formatPath(workDir.appendPath(srcname), false);
                if (ext != nilptr && (ext.equalsIgnoreCase(".xcs") || ext.equalsIgnoreCase(".xcsm") || ext.equalsIgnoreCase(".version")) ){
					if (fixver){
						if (ext.equalsIgnoreCase(".version")){
							versionIncrement(builder, fullsourcePath);
						}
                    }
					String source = "\"" + fullsourcePath + "\" ";
					sourceArgs.add(source);
                }
			}
		}else{
			for (int i = 0; i < sources.length(); i++){
            	String srcname = sources.getString(i);
                String ext = srcname.findExtension();
                String fname = srcname.findFilenameAndExtension();
                
                String fullsourcePath = String.formatPath(workDir.appendPath(srcname), false);
                
                if (fname.equalsIgnoreCase("makefile")){
					makefile(builder, object, configure, workDir);
                }
                if (ext != nilptr && (ext.equalsIgnoreCase(".xcs") || ext.equalsIgnoreCase(".xcsm") || ext.equalsIgnoreCase(".version")) ){
					if (fixver){
						if (ext.equalsIgnoreCase(".version")){
							versionIncrement(builder, fullsourcePath);
						}
                    }
					sourceArgs.add(fullsourcePath);
                }
			}
		}

        
        return sourceArgs;
    }
    
   static String getArch(Configure configure){
		String [] archs = {"unknow", "x86", "x64", "arm", "arm64", "mips"};
        
		String arch = configure.getOption("wtype");
        if (arch.equals("")){
			int aid = _system_.getArchId();
            
            if (aid < 0 || aid > 5){
				aid = 0;
            }
            return archs[aid];
            
        }else{
			if (arch.equals("-arch:x86")){
				return archs[1];
            }else
            if (arch.equals("-arch:x86_64")){
				return archs[2];
            }else
            if (arch.equals("-arch:arm")){
				return archs[3];
            }else
            if (arch.equals("-arch:arm64")){
				return archs[4];
            }else
            if (arch.equals("-arch:mips")){
				return archs[5];
            }else{
				return archs[0];
            }
        }
    }
    
    String getArchArgs(Configure configure){
		String [] archs = {"", "-arch:x86", "-arch:x86_64", "-arch:arm", "-arch:arm64", "-arch:mips"};
        
		String arch = configure.getOption("wtype");
        if (arch.equals("")){
			int aid = _system_.getArchId();
            
            if (aid <= 0 || aid > 5){
				aid = 1;
            }
            return archs[aid];
            
        }else{
			return arch;
        }
    }
    
    String getXcrossName(Configure configure){
		String [] archs = {"", "-xcross-windows", "-xcross-linux", "-xcross-darwin"};
        
		String arch = configure.getOption("ostype");
        if (arch.equals("") == false){
        
			int aid = _system_.getArchId();
            
            if (aid <= 0 || aid > 3){
				aid = 1;
            }
            return archs[aid + 1];
            
        }else{
			return arch;
        }
    }
    
    static String map_variable(Project object, Configure configure, String text){
		text = text.replace("$(Output)", configure.getOption("outpath").appendPath(configure.getOption("outname")));
        text = text.replace("$(Configure)", configure.getName());
        text = text.replace("$(Arch)", getArch(configure));
        
        String ptype = configure.getOption("command");
        String ostype = configure.getOption("ostype");
        
        String ext = "";
        
		if (ptype.equals("-ce")){
			if (ostype.length() == 0 || ostype.equalsIgnoreCase("-xcross-windows")){
				if (_system_.getPlatformId() == 0){
					ext = ".exe";
				}
			}
		}else
		if (ptype.equals("-lix -c")){
			ext = ".lix";
		}else
		if (ptype.equals("-c")){
			ext = ".exc";
		}      
        
        
        text = text.replace("$(Ext)", ext);
        
        return object.map_variable(text);
    }
    
    void generateJsonArrayArgs(String key, JsonArray incpath, Vector<String> args){
		if (incpath != nilptr){
			String incs = "";
            bool pushkey = false;
			for (int i = 0; i < incpath.length(); i++){
				String inc = incpath.getString(i);
				if (inc != nilptr && inc.length() > 0){
					if (pushkey == false){
						args.add(key);
                        pushkey = true;
					}
                    if (_system_.getPlatformId() == 0){
						args.add("\"" + inc + "\"");
                    }else{
						args.add(inc);
                    }
				}
			}
		}
    }
    
    void generatePath(Configure configure, Vector<String> args){
        if (configure.root == nilptr){
			return ;
        }
        
        JsonObject paths = (JsonObject)configure.root.get("path");
        if (paths != nilptr){
			JsonArray incpath = (JsonArray)paths.get("incpath");
            JsonArray libpath = (JsonArray)paths.get("libpath");
			generateJsonArrayArgs("-incpath", incpath, args);
            generateJsonArrayArgs("-libpath", libpath, args);
        }

    }
    
    void generateLibs(Configure configure, Vector<String> args){
        if (configure.root == nilptr){
			return ;
        }
        
        JsonArray libs = (JsonArray)configure.root.get("libs");
        generateJsonArrayArgs("-lib", libs, args);
    }
        
        
    void checkOptions(Vector<String> args, Configure configure, String []key){
		for (int i =0; i < key.length; i++){
			String option = configure.getOption(key[i]);
			
			if (option != nilptr && option.length() > 0){
				args.add(option);
			}else
            if (key[i].equals("wtype")){
				String wtype = getArchArgs(configure);
                if (wtype.length() > 0){
					args.add(wtype);
                }
            }else
            if (key[i].equals("ostype")){
				String ostype = getXcrossName(configure);
                if (ostype.length() > 0){
					args.add(ostype);
                }
            }
        }
    }
    
    String [] generateBuildArgs(Vector<String> __args, Project object, Configure configure, BuildParams param){
        Vector<String> args = new Vector<String>();

		String []options = {"ignorewarning", "debugdatabase", "debugable", "wtype", "ostype"};
        
		checkOptions(args, configure, options);

        //路径变量
        generatePath(configure, args);
                
        //外部库
        generateLibs(configure, args);

		String uac = configure.getOption("uaclevel");
        if (uac.length() > 0){
			if (uac.equals("管理员(-uac-admin)")){
				args.add("-uac-admin");
            }else
            if (uac.equals("最高级别(-uac-highest)")){
				args.add("-uac-highest");
            }
        }
        
		String icofile = object.getOption("icofile");
        
        if (icofile.length() > 0){
			args.add("-ico");
            icofile = map_variable(object, configure, icofile);
			if (_system_.getPlatformId() == 0){ /* windows */
				args.add("\"" + icofile + "\"");
			}else{
				args.add(icofile);
			}
        }
        
		args.add("-o");

        String out_path = configure.getOption("outpath");
        
        if (param != nilptr){
			out_path = param.output_source;
			if (_system_.getPlatformId() == 0){ /* windows */
				args.add("\"" + out_path + "\"");
			}else{
				args.add(out_path);
			}
        }else{
        
			out_path = String.formatPath(map_variable(object, configure, out_path), false);
			mkdirs(out_path);
			
			if (_system_.getPlatformId() == 0){ /* windows */
				args.add("\"" + out_path.appendPath(configure.getOption("outname")) + "\"");
			}else{
				args.add(out_path.appendPath(configure.getOption("outname")));
			}
        }
        String [] szArgs = new String[args.size() + __args.size()];

		int argpos = 0;

        for (int i = 0; i < __args.size(); i++){
            szArgs[argpos++] = XPlatform.converToPlatformCharSet(__args.get(i));
        }

        for (int i = 0; i < args.size(); i++){
            szArgs[argpos++] = XPlatform.converToPlatformCharSet(map_variable(object, configure, args.get(i)));
        }
        
        return szArgs;
    }
    

    
    static bool mkdirs(String path){
        if (XPlatform.existsSystemFile(path) == false){
            if (XPlatform.mkdir(path) == false){
                mkdirs(path.findVolumePath());
                return XPlatform.mkdir(path);
            }
        }
        return true;
    }
    
    int detectInfo(String line){
        if (line.endWith(warning)){
            return ICompileInfo.WARNING;
        }
        if (line.endWith(error)){
            return ICompileInfo.ERROR;
        }
        if (line.endWith(tips)){
            return ICompileInfo.TIPS;
        }
        return -1;
    }
    
    Vector<ICompileInfo> parseInfo(String info){
        Vector<ICompileInfo> infos = new Vector<ICompileInfo>();
        String [] list = info.split("\n");
        if (list != nilptr){
            for (int i = 0; i < list.length; i++){
                String message = list[i].trim(true);
                int t = detectInfo(message);
                if (t != -1){
					String tips_block = message;
                    i++;
					for (; i < list.length; i++){
                        if (list[i].startWith(" ")){
							tips_block = tips_block + "\n" + list[i];
                        }else{
							i--;
							break;                        
                        }
                    }
                    infos.add(new CompileInfo(message, t, tips_block));
                }
            }
        }
        return infos;
    }
    
    void cleanup(IBuilder builder, Project object, Configure configure)override{
		batchbuild(builder, object, configure, "preclean");
        
        String workdir = object.projpath.findVolumePath();

        JsonArray sources = object.getSources();
        
		if (_system_.getPlatformId() != 0){ /* linux unix */
			for (int i = 0; i < sources.length(); i++){
            	String srcname = sources.getString(i);

                String fname = srcname.findFilenameAndExtension();
                
                if (fname.equalsIgnoreCase("makefile")){
					makefile_clean(builder, object, configure, workdir);
                }
			}
		}
        
        String target = getTarget(object, configure);

		builder.OutputText(target + "... \n");
        
        if (XPlatform.existsSystemFile(target)){
			if (false == XPlatform.deleteFile(target)){
				builder.OutputText("文件正在使用中,清理失败\n");
			}
        }
        
        batchbuild(builder, object, configure, "afterclean");
        
        builder.OutputText("[" + String.formatDate("%c", _system_.currentTimeMillis()) + "] 清理完成.\n");
    }
    
    
    class XKernel32 : Library {
    
		static bool loaded = false;
        
        static bool load(){
			if (loaded == false){
				try{
					loadLibrary("kernel32.dll");
                    loaded = true;
                }catch(Exception e){
					
                }
            }
            return loaded;
        }
        
        static String getWindowsDir(){
			if (load()){
				byte [] dir = new byte[320];
                int pathlen = GetWindowsDirectoryA(dir, 320);
                return new String(dir, 0, pathlen);
            }
            return nilptr;
        }
        
		import{
			 int stdcall GetWindowsDirectoryA(
			  ObjectPtr lpBuffer,
			  int  uSize
			);
        };
    };

    
    void runbat(IBuilder builder, String batfile, String projectDir){
		String [] margs = {"cmd", "/c", batfile};
        
        String execute = XKernel32.getWindowsDir();
        if (execute == nilptr){
			return;
        }
        
        execute = String.formatPath( execute.appendPath("system32\\cmd.exe"), false);
		Process _mprocess = new Process(execute, margs);
        _mprocess.setWorkDirectory(projectDir);
        
        String statusoutput = "bat scripts " + batfile;
            
        builder.OutputText(statusoutput + "\n");
        
        try{
			if (_mprocess.create(false, true, false, false)){
				Utils.readForProcess(builder, _mprocess);
				_mprocess.waitFor(-1);
			}else{
				builder.OutputText("\n build scripts失败.\n");
			}

        }catch(Exception e){
			String str = e.getMessage();
			builder.OutputText("\n错误:" + XPlatform.converPlatformCharSetTo(str) + "\n");
        }
    }
    
    void runsh(IBuilder builder, String shfile, String projectDir){
		String [] margs = {"bash", "-c", shfile};
		Process _mprocess = new Process("/bin/bash", margs);
        _mprocess.setWorkDirectory(projectDir);
        
        String statusoutput = "bash scripts " + shfile;
            
        builder.OutputText(statusoutput + "\n");
        
        try{
			if (_mprocess.create(false, true, false, false)){
				Utils.readForProcess(builder, _mprocess);
				_mprocess.waitFor(-1);
			}else{
				builder.OutputText("\n build scripts失败.\n");
			}

        }catch(Exception e){
			String str = e.getMessage();
			builder.OutputText("\n错误:" + XPlatform.converPlatformCharSetTo(str) + "\n");
        }
    }
    
    void batchbuild(IBuilder builder, Project object, Configure configure, String key){
		String workdir = object.projpath.findVolumePath();
    
		String txt = configure.getOption(key);
        
        if (txt == nilptr || txt.length() == 0){
			return;
        }
        
		String batfile = map_variable(object, configure, txt);
        
        int osid = _system_.getPlatformId();
        
        if (osid == 0){
			runbat(builder, batfile, workdir);
        }else{
			runsh(builder, batfile, workdir);
        }
    }

    
    void build(IBuilder builder, Project object, Configure configure, Object param)override{
    
		batchbuild(builder, object, configure, "prebuild");
        
        String workdir = object.projpath.findVolumePath();

        Vector<String> _args = getSourceArgs(builder, object, configure, workdir, (BuildParams)param);

        String allInfo = "";
        if (configure == nilptr){
            Map.Iterator<String, Configure> iter = object.configures.iterator();
            
            while (iter.hasNext()){
                Configure conf = iter.getValue();
                String []args = generateBuildArgs(_args, object, conf, nilptr);
                allInfo = allInfo + builder.build(getCompilerPath(), args, workdir);
                iter.next();
            }
        }else{
            String []args = generateBuildArgs(_args, object, configure, (BuildParams)param);
            allInfo = allInfo + builder.build(getCompilerPath(), args, workdir);
        }
        
        batchbuild(builder, object, configure, "afterbuild");
        
        builder.setCompileInfor(parseInfo(allInfo));
    }

	void stopRun()override{
		if (process != nilptr){
			process.exit(0);
		}
	}
    
    String getTarget(Project object, Configure configure){
        String out_path = map_variable(object, configure, "$(Output)");
		return String.formatPath(out_path, false);
    }
    
    String getExecuteCmd(Project object, Configure configure){
        String out_path = configure.getOption("cmd");
        out_path = map_variable(object, configure, out_path);
		return String.formatPath(out_path, false);
    }
    String getExecuteWd(Project object, Configure configure){
        String out_path = configure.getOption("workdir");
        out_path = map_variable(object, configure, out_path);
        return String.formatPath(out_path, false);
    }
    
    Vector<String> processArgs(String args){
		Vector<String> args_list = new Vector<String>();
        
        byte []data = args.getBytes();
        
        int start = 0;
        bool inline = false;
        
        for (int i = 0; i < data.length; i++){
			
			if (data[i] == '"'){
				inline = !inline;
            }
            
            if (inline == false){
            
				if (data[i] == ' '){
                
					String arg = new String(data, start, i - start);
                    
                    start = i + 1;
                    
                    args_list.add(arg);
				}
            }
        }
        
        if (start < data.length){
			String arg = new String(data, start, data.length - start);
            args_list.add(arg);
        }
        
        return args_list;
    }
    
    Vector<String> getExecuteArgs(Project object, Configure configure){
		
        String out_path = configure.getOption("args");
        
        String args = String.formatPath(map_variable(object, configure, out_path), false);
        
        return processArgs(args);
    }
     
    int getDebugSerial(){
		if (XDEBUG_SERIAL == 0){
			XDEBUG_SERIAL = Process.getId() * 100;
        }else{
			XDEBUG_SERIAL++;
        }
		return XDEBUG_SERIAL;
    }
    
    
    bool checkDebugFlag(String path){
		long hf = XPlatform.openSystemFile(path, "r");
        if (hf == 0){
			return false;
        }
        
        bool bret = false;
        
        _system_.seekFile(hf, Stream.SeekEnd, -4);
        
        byte[] flag = new byte[4];
        if (4 == _system_.readFile(hf, flag, 0, 4)){
			if (flag[0] == 'x' && flag[1] == 'd' && flag[2] == 'b'&& flag[3] == 'g'){
				bret = true;
            }
        }
        _system_.closeFile(hf);
        
        return bret;
    }
    
    void debugRun(IBuilder builder, Project proj, Configure conf)override{
		if (XWorkspace.isDebugging()){
			builder.OutputText("\调试器已在运行中,请等待当前调试工作结束.\n");
            return ;
        }
        int debugSerial = getDebugSerial();
        
        String exePath = getExecuteCmd(proj, conf);/*getBuildFile(proj, conf);*/
        
		if (_system_.getPlatformId() != 2){
			if (checkDebugFlag(exePath) == false){
				if (XPlatform.existsSystemFile(exePath) == false){
					builder.OutputText("\n没有找到目标程序:" + exePath + ",请先编译生成.\n");
				}else{
					builder.OutputText("\n目标程序:" + exePath + "不支持调试,请在[项目]->[属性]->[编译选项]中开启调试后重新编译\n");
				}
				XWorkspace.workspace.notSupportDebug();
				return ;
			}
        }
        Vector<String> args = getExecuteArgs(proj, conf);
        args.add("-xdbg:" + debugSerial);
        
        String []args__ = nilptr;
        
        if (args.size() > 0){
			args__ = new String[args.size()];
            for (int i =0; i < args__.length; i++){
				args__[i] = XPlatform.converToPlatformCharSet(args.get(i));
            }
        }
        
        process = new Process(XPlatform.converToPlatformCharSet(exePath), args__);
        process.setWorkDirectory(XPlatform.converToPlatformCharSet(getExecuteWd(proj, conf)));
        
        String statusoutput = "\n运行: " + exePath + " ";

		for (int i = 0; i < args.size(); i++){
			statusoutput = statusoutput + args.get(i) + " ";
		}
            
        builder.OutputText(statusoutput + "\n");
        
        try{
			if (XWorkspace.workspace.debugPrepare("127.0.0.1", debugSerial)){
				bool readforstdout = _system_.getPlatformId() != 0;
				if (process.create(true, readforstdout, false, false)){
					builder.OutputText("\n已创建进程 ID: " + process.id() + "\n");

					if (XWorkspace.workspace.debug() == false){
						builder.OutputText("\n调试器失败.\n");
                        process.exit(0);
                    }
                    if (readforstdout){
						Utils.readForProcess(builder, process);
                    }
					process.waitFor(-1);
                    //XWorkspace.workspace.debugClose();
					builder.OutputText("\n退出代码: " + process.getExitCode() + "\n");
				}else{
					
					builder.OutputText("\n运行失败.\n");
				}
            }else{
				builder.OutputText("\n调试器正忙.\n");
            }
        }catch(Exception e){
        
			if (e.getErrorCode() == 0x000002E4){
				XWorkspace.workspace.runOnUi(new Runnable(){
					void run()override{
						if (QXMessageBox.Question("注意", "被调试程序需要提升权限, 是否重新以提升的权限运行?", QXMessageBox.Ok | QXMessageBox.Cancel, QXMessageBox.Ok) == QXMessageBox.Ok){
							XWorkspace.runAsAdministrator();
                        }
                    }
                });
            }
            
			String str = e.getMessage();
			
			builder.OutputText("\n错误:" + new String(str.getBytes(), "GB18030//IGNORE") + "\n");
        }finally{
			XWorkspace.workspace.debugClose();
        }
    }
    
    void Run(IBuilder builder, Project proj, Configure conf)override{
        
        String exePath = getExecuteCmd(proj, conf);/*getBuildFile(proj, conf);*/
        
        if (XPlatform.existsSystemFile(exePath) == false){
			builder.OutputText("\n没有找到目标程序:" + exePath + ",请先编译生成.\n");
            return ;
		}
        
        Vector<String> args = getExecuteArgs(proj, conf);
        
        String []args__ = nilptr;
        
        if (args.size() > 0){
			args__ = new String[args.size()];
            for (int i =0; i < args__.length; i++){
				args__[i] = XPlatform.converToPlatformCharSet(args.get(i));
            }
        }
        
        process = new Process(XPlatform.converToPlatformCharSet(exePath), args__);
        process.setWorkDirectory(XPlatform.converToPlatformCharSet(getExecuteWd(proj, conf)));
        
        builder.OutputText("\n运行: " + exePath + "\n");
        
        try{
			bool readforstdout = _system_.getPlatformId() != 0;
            if (process.create(true, readforstdout, false, false)){
				if (readforstdout){
					Utils.readForProcess(builder, process);
				}
                process.waitFor(-1);
                builder.OutputText("\n退出代码: " + process.getExitCode() + "\n");
            }else{
                builder.OutputText("\n运行失败.\n");
            }
        }catch(Exception e){
			String str = e.getMessage();
			
			builder.OutputText("\n错误:" + new String(str.getBytes(), "GB18030//IGNORE") + "\n");
        }
    }
    
    static bool copyFile(String source, String dest){
		if (XPlatform.existsSystemFile(source)){
			try{
				FileOutputStream fos = new FileOutputStream(dest);
				fos.write(new FileInputStream(source).read());
				fos.close();
				return true;
			}catch(Exception e){
			
			}
        }
        return false;
    }
    
    
    bool createZTemplateProject(WizardLoader loader,String projectName, String projectDir, String uuid){
		XPlatform.mkdir(projectDir);
        
		String confFile = XPlatform.getAppDirectory().appendPath("config").appendPath(uuid + ".utemp");
        
        String destProj = projectDir.appendPath(projectName + ".xprj");
        
        if (extartToDir(confFile, projectDir, projectName)){
			generateProjectFile(destProj, projectName);
            generateLibs(projectDir, uuid);
        }
        
		loader.loadProject(destProj);
		return true;
    }
    
    void copyQtLibs(String projectDir){
		String source = XPlatform.getAppDirectory().appendPath("lib").appendPath("QXLibrary.lix");
		String dest = projectDir.appendPath("libs").appendPath("QXLibrary.lix");
		copyFile(source, dest);
		
		source = XPlatform.getAppDirectory().appendPath("lib").appendPath("x86").appendPath("QXLibrary.dll");
		dest = projectDir.appendPath("x86").appendPath("debug").appendPath("QXLibrary.dll");
		copyFile(source, dest);
        
 		source = XPlatform.getAppDirectory().appendPath("lib").appendPath("x86_64").appendPath("QXLibrary.dll");
		dest = projectDir.appendPath("x64").appendPath("debug").appendPath("QXLibrary.dll");
		copyFile(source, dest);
  
		source = XPlatform.getAppDirectory().appendPath("lib").appendPath("x86").appendPath("QXLibrary.so");
		dest = projectDir.appendPath("x86").appendPath("debug").appendPath("QXLibrary.so");
		copyFile(source, dest);
        
 		source = XPlatform.getAppDirectory().appendPath("lib").appendPath("x86_64").appendPath("QXLibrary.so");
		dest = projectDir.appendPath("x64").appendPath("debug").appendPath("QXLibrary.so");
		copyFile(source, dest);   
        
 		source = XPlatform.getAppDirectory().appendPath("lib").appendPath("x86_64").appendPath("QXLibrary.dylib");
		dest = projectDir.appendPath("x64").appendPath("debug").appendPath("QXLibrary.dylib");
		copyFile(source, dest);             
    }
    
    bool generateLibs(String projectDir, String uuid){
		String [] qtprojs = {"0ef0fe5d-5ab9-4d62-ab6a-ee78f059ad1e", "5e5ab583-973f-41cd-98cb-ac5208557f8b"};
    
		for (int i =0; i < qtprojs.length; i++){
			if (qtprojs[i].equals(uuid)){
				copyQtLibs(projectDir);
                break;
            }
        }
        
        return true;
    }
    
    bool generateProjectFile(String destFile, String projectName){
		try{
			FileInputStream fis = new FileInputStream(destFile);
			byte [] data = fis.read();
			String content = new String(data);
			content = content.replace("${ProjectName}", projectName);
			fis.close();
			
			FileOutputStream fos = new FileOutputStream(destFile);
			byte [] odata = content.getBytes();
			fos.write(odata);
			fos.close();
		}catch(Exception e){
			return false;
		}
        return true;
    }
    
    bool createTemplateProject(WizardLoader loader,String projectName, String projectDir, String uuid){
		XPlatform.mkdir(projectDir);
        
        
		String confFile = "./config/" + uuid + ".prop";
		String destProj = projectDir.appendPath(projectName + ".xprj");
		try{
			FileInputStream fis = new FileInputStream(confFile);
			byte [] data = fis.read();
			String content = new String(data);
			content = content.replace("${ProjectName}", projectName);
			
			
			FileOutputStream fos = new FileOutputStream(destProj);
			byte [] odata = content.getBytes();
			fos.write(odata);
			fos.close();
			String mainFile = projectDir.appendPath(projectName + ".xcs");
			fos = new FileOutputStream(mainFile);
            
            confFile = "./config/" + uuid + ".temp";
			fis = new FileInputStream(confFile);
			data = fis.read();
			content = new String(data);    
			fos.write(content.getBytes());
			fos.close();
		}catch(Exception e){
			return false;
		}
		loader.loadProject(destProj);
		return true;
    
    }
        
	bool createNormalProject(WizardLoader loader,String projectName, String projectDir, String uuid){
		XPlatform.mkdir(projectDir);
		String confFile = "./config/" + uuid + ".prop";
		String destProj = String.formatPath(projectDir.appendPath(projectName + ".xprj"), false);
		try{
			FileInputStream fis = new FileInputStream(confFile);
			byte [] data = fis.read();
			String content = new String(data);
			content = content.replace("${ProjectName}", projectName);
			
			
			FileOutputStream fos = new FileOutputStream(destProj);
			byte [] odata = content.getBytes();
			fos.write(odata);
			fos.close();
			String mainFile = projectDir.appendPath(projectName + ".xcs");
			fos = new FileOutputStream(mainFile);
            String out_class = 	"//xlang " + 
								"\npackage System{" + 
								"\n	class out{" +
								"\n		static int println(String text){"	+
								"\n			return _system_.consoleWrite(text + \"\\n\");" +
                                "\n		}"	+
                                "\n		static int print(String text){"	+
								"\n			return _system_.consoleWrite(text);" +
                                "\n		}"	+
                                "\n	};" +
                                "\n	"	+
                                "\n	class Console{"	+
                                "\n		Console(){"	+
                                "\n			_system_.createConsole();" +
                                "\n		}" +
                                "\n	};" +
                                "\n};" + 
                                "\n\n" +
                                "\nusing { System; };"	+
                                "\n\n" +
                                "\nint main(String [] args){"	+
                                "\n\n	new Console();"	+
                                "\n\n	System.out.println(\"hello world\");" +
                                "\n\n	Thread.sleep(3000);"	+
                                "\n\n	return 0;"	+
                                "\n}\n";
                                
			fos.write(out_class.getBytes());
			fos.close();
		}catch(Exception e){
			return false;
		}
		loader.loadProject(destProj);
		return true;
	}
    
    bool extartToDir(String zfile, String dir, String projName){
		
        FileInputStream fis;
        
        try{
			fis = new FileInputStream(zfile);
        }catch(Exception e){
			return false;
        }
        
        bool bSuccess = true;
        ZipArchive zs = new ZipArchive();
		if (zs.open(fis)){
			int c = zs.getEntriesCount();
			for (int i =0; i < c; i ++){
				ZipEntry entry = zs.getEntry(i);
				if (bSuccess == false){
					break;
                }
                String entryName = entry.getName();
                entryName = entryName.replace("${ProjectName}", projName);
                
                String path = String.formatPath(dir.appendPath(entryName), false);
                
				if (entry.isDirectory() == false){
					ZipFile file = entry.getFile();
					
					byte []buf = new byte[1024];
					int rd = 0;
					if (file.open()){
						long filehandler = XPlatform.openSystemFile(path, "w");
                        if (filehandler != 0){
							while ((rd = file.read(buf, 0, 1024)) != 0){
								_system_.writeFile(filehandler, buf, 0, rd);
							}
							_system_.closeFile(filehandler);
                        }else{
							bSuccess = false;
                        }
						file.close();
					}else{
						bSuccess = false;
                    }
				}else{
					XPlatform.mkdir(path);
                }
			}
            zs.close();
		}else{
			bSuccess = false;
        }
        
        return bSuccess;
    }
    
    byte [] getContentForNewFile(String filename,Project project, String uuid){
		
        String projectName = "XApp";
        if (project != nilptr){
			projectName = project.getName();
        }
		if (uuid.equals("f55e671c-d2fe-4414-b060-fac629ccda6d")){
        //ui
			String default_content = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + 
			"<ui version=\"4.0\">" + 
			" <class>MainWindow</class>" + 
			" <widget class=\"QMainWindow\" name=\"MainWindow\">" + 
			"  <property name=\"geometry\">" + 
			"   <rect>" + 
			"    <x>0</x>" + 
			"    <y>0</y>" + 
			"    <width>719</width>" + 
			"    <height>545</height>" + 
			"   </rect>" + 
			"  </property>" + 
			"  <property name=\"windowTitle\">" + 
			"   <string>MainWindow</string>" + 
			"  </property>" + 
			"  <widget class=\"QWidget\" name=\"centralwidget\"/>" + 
			"  <widget class=\"QMenuBar\" name=\"menubar\">" + 
			"   <property name=\"geometry\">" + 
			"    <rect>" + 
			"     <x>0</x>" + 
			"     <y>0</y>" + 
			"     <width>719</width>" + 
			"     <height>23</height>" + 
			"    </rect>" + 
			"   </property>" + 
			"  </widget>" + 
			"  <widget class=\"QStatusBar\" name=\"statusbar\"/>" + 
			" </widget>" + 
			" <resources/>" + 
			" <connections/>" + 
			"</ui>";
			return default_content.getBytes();
        }else 
        if (uuid.equals("f48d4411-6b02-4f8b-a961-23a2e079c55c")){
        // version
			JsonObject json = new JsonObject();
            json.put("FileVersion", "1.0.0.0");
            json.put("ProductVersion", "1.0.0.0");
            
            json.put("ProductName", projectName);
            json.put("InternalName", projectName + ".exe");
            
            json.put("CompanyName", "XStudio");
            json.put("LegalCopyright", "Copyright (C) 2018 X-Studio");
            
            json.put("FileDescription", projectName);
            
            return json.toString(true).getBytes();
        }
        
		String date = String.formatDate("%c", _system_.currentTimeMillis()); 
		return ("//xlang Source, Name:" + filename + " \n" + "//Date: " + date + " \n").getBytes();
	
    }
	bool createNormalFileToProject(WizardLoader loader,String projectName, String projectDir, String uuid, Project ownProject, bool addToProject, String ext){
		XPlatform.mkdir(projectDir);
		try{
			String extsion = projectName.findExtension();
			String filename ;
			if (extsion != nilptr){
				filename = projectName;
			}else{
				filename = projectName + ext;
			}
				
			String destProj = String.formatPath(projectDir.appendPath(filename), false);
			
            if (XPlatform.existsSystemFile(destProj)){
				if (QXMessageBox.Question("注意", destProj + "<a style=\"color:#ffff0000\">继续建立新文件将改写原有文件?</a>", QXMessageBox.Ok | QXMessageBox.No, QXMessageBox.Ok) == QXMessageBox.No){
					return false;
                }
            }
            
			FileOutputStream fos = new FileOutputStream(destProj);
			
			fos.write(getContentForNewFile(filename, ownProject, uuid));
			fos.close();
			loader.openTextFile(destProj);
			if (addToProject){
				return ownProject.addSource(destProj);
			}
			return true;
		}catch(Exception e){
			
		}
		return false;
	}
	bool create(WizardLoader loader, String projectName, String projectDir, String uuid, Project ownProject, bool addToProject, String userType)override{
    
		if (userType != nilptr && userType.equals("project")){
			if (Pattern.test(projectName, "^[A-Za-z0-9_]+$", Pattern.NOTEMPTY, true) == false){
				QXMessageBox.Critical("错误", "项目名称不合法", QXMessageBox.Ok, QXMessageBox.Ok);
				return false;
			}
			String priject_dir = String.formatPath(projectDir.appendPath(projectName), false);
			if (XPlatform.existsSystemFile(priject_dir)){
				QXMessageBox.Critical("错误", "该位置已存在同名项目, 请重新选择路径或者改变项目名", QXMessageBox.Ok, QXMessageBox.Ok);
				return false;
			}else{
				if (mkdirs(priject_dir) == false){
					QXMessageBox.Critical("错误", "无法在此位置建立新目录, 请重新选择路径", QXMessageBox.Ok, QXMessageBox.Ok);
					return false;
				}
			}
            return createZTemplateProject(loader, projectName, priject_dir, uuid);
        }
        
		if (uuid.equals("100911ae-27e8-4479-a56f-af015358f1a6")){
			if (Pattern.test(projectName, "^[A-Za-z0-9_]+$", Pattern.NOTEMPTY, true) == false){
				QXMessageBox.Critical("错误", "项目名称不合法", QXMessageBox.Ok, QXMessageBox.Ok);
				return false;
			}
			String priject_dir = String.formatPath(projectDir.appendPath(projectName), false);
			if (XPlatform.existsSystemFile(priject_dir)){
				QXMessageBox.Critical("错误", "该位置已存在同名项目, 请重新选择路径或者改变项目名", QXMessageBox.Ok, QXMessageBox.Ok);
				return false;
			}else{
				if (mkdirs(priject_dir) == false){
					QXMessageBox.Critical("错误", "无法在此位置建立新目录, 请重新选择路径", QXMessageBox.Ok, QXMessageBox.Ok);
					return false;
				}
			}
			return createNormalProject(loader, projectName, priject_dir, uuid);
		}
        
		if (uuid.equals("76d637db-bbaa-4a4f-907b-84d3a8cc15a2") || 
			uuid.equals("e5787cae-9900-4c41-9eb5-08e61cfc0fb2")	|| 
			uuid.equals("651c2524-d9a5-40e9-b6cf-3d480bc75631") || 
            uuid.equals("0ef0fe5d-5ab9-4d62-ab6a-ee78f059ad1e") || 
            uuid.equals("85384b44-719b-4aaa-8c8b-ad5ecec4201b") || 
            uuid.equals("5e5ab583-973f-41cd-98cb-ac5208557f8b") )
        {
                        
			if (Pattern.test(projectName, "^[A-Za-z0-9_]+$", Pattern.NOTEMPTY, true) == false){
				QXMessageBox.Critical("错误", "项目名称不合法", QXMessageBox.Ok, QXMessageBox.Ok);
				return false;
			}
			String priject_dir = String.formatPath(projectDir.appendPath(projectName), false);
			if (XPlatform.existsSystemFile(priject_dir)){
				QXMessageBox.Critical("错误", "该位置已存在同名项目, 请重新选择路径或者改变项目名", QXMessageBox.Ok, QXMessageBox.Ok);
				return false;
			}else{
				if (mkdirs(priject_dir) == false){
					QXMessageBox.Critical("错误", "无法在此位置建立新目录, 请重新选择路径", QXMessageBox.Ok, QXMessageBox.Ok);
					return false;
				}
			}
            return createZTemplateProject(loader, projectName, priject_dir, uuid);
        }
        
		if (uuid.equals("262b6f61-478a-4968-b800-1f22520ef0bf")){
			return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".xcs");
		}
		if (uuid.equals("8f95f230-7662-4543-9495-6f7cd083c2b9")){
			return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".xcsm");
		}
        if (uuid.equals("f55e671c-d2fe-4414-b060-fac629ccda6d")){
			return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".ui");
        }
        if (uuid.equals("f48d4411-6b02-4f8b-a961-23a2e079c55c")){
			return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".version");
        }
		return false;
	}
};